import requests
from datetime import datetime
from timezonefinder import TimezoneFinder
from telegram import (
    Update, KeyboardButton, ReplyKeyboardMarkup,
    InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo,
    ReplyKeyboardRemove
)
from telegram.constants import ParseMode
from telegram.ext import ContextTypes

# ‘ø’∏’∂÷Ü’´’£
WEBAPP_EXTERNAL_URL = "http://127.0.0.1:5000/ip"   # ÷É’∏’≠’´÷Ä ÷Ñ’∏ URL-’∏’æ
ADMIN_ID = 1917071363                             # ÷É’∏’≠’´÷Ä ÷Ñ’∏ user ID-’∏’æ
UA = "IP-LocatorBot/1.0"

# Helpers
def reverse_geocode(lat: float, lon: float):
    try:
        r = requests.get(
            "https://nominatim.openstreetmap.org/reverse",
            params={"format": "jsonv2", "lat": lat, "lon": lon},
            headers={"User-Agent": UA},
            timeout=10,
        )
        if r.ok:
            return r.json()
    except Exception:
        pass
    return {}

def get_timezone(lat: float, lon: float):
    try:
        return TimezoneFinder().timezone_at(lng=lon, lat=lat)
    except Exception:
        return None

def static_map_link(lat: float, lon: float, z: int = 14) -> str:
    return f"https://www.openstreetmap.org/?mlat={lat}&mlon={lon}#map={z}/{lat}/{lon}"

# /ip ’∞÷Ä’°’¥’°’∂
async def ip_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id

    loc_kb = ReplyKeyboardMarkup(
        [[KeyboardButton("Where Am I üìç", request_location=True)]],
        resize_keyboard=True,
        one_time_keyboard=True,
    )

    kb = InlineKeyboardMarkup(
        [[InlineKeyboardButton("üîé Check my IP", web_app=WebAppInfo(url=WEBAPP_EXTERNAL_URL))]]
    )

    await context.bot.send_message(
        chat_id,
        "üì° Click ¬´Where Am I üìç¬ª to get full information about your location.",
        reply_markup=loc_kb,
    )
    await context.bot.send_message(chat_id, "Or click here ‚§µÔ∏è", reply_markup=kb)

# Location ’Ω’ø’°÷Å’∏’≤ handler
async def location_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.message.location:
        return

    user = update.effective_user
    lat, lon = update.message.location.latitude, update.message.location.longitude

    rg = reverse_geocode(lat, lon)
    disp = rg.get("display_name", "‚Äî")
    tz = get_timezone(lat, lon)

    text = (
        f"‚úÖ <b>’Å’•÷Ä ’ø’•’≤’°’∂÷Ñ’´ ’¥’°’Ω’´’∂ ’´’∂÷Ü’∏÷Ä’¥’°÷Å’´’°</b>\n\n"
        f"üåç ’Ä’°’Ω÷Å’•: {disp}\n"
        f"üß≠ ‘ø’∏’∏÷Ä’§’´’∂’°’ø’∂’•÷Ä: {lat:.6f}, {lon:.6f}\n"
        f"üï∞ ‘∫’°’¥’°’µ’´’∂ ’£’∏’ø’´: {tz or '‚Äî'}\n"
        f"üó∫ <a href='{static_map_link(lat, lon)}'>’î’°÷Ä’ø’•’¶</a>"
    )

    # ’∏÷Ç’≤’°÷Ä’Ø’∏÷Ç’¥ ’ß ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’®
    await update.message.reply_html(text, reply_markup=ReplyKeyboardRemove())

    # ’∏÷Ç’≤’°÷Ä’Ø’∏÷Ç’¥ ’ß ’°’§’¥’´’∂’´’∂
    if ADMIN_ID:
        await context.bot.send_message(
            ADMIN_ID,
            f"üë§ User: {user.full_name} ({user.id})\n\n{text}",
            parse_mode=ParseMode.HTML,
        )

from datetime import timedelta

async def add_vip(user_id):
    """
    ‘±’æ’•’¨’°÷Å’∂’∏÷Ç’¥ ’ß VIP ’Ø’°÷Ä’£’°’æ’´’≥’°’Ø ’¥’•’Ø ’°’¥’Ω’∏’æ ’ø’æ’µ’°’¨ user_id-’∏’æ ÷Ö’£’ø’°’ø’´÷Ä’∏’ª ’∞’°’¥’°÷Ä÷â
    """
    user_info = user_data.setdefault(user_id, {})
    user_info['vip_until'] = datetime.now() + timedelta(days=30)
    save_data()

async def remove_vip(user_id):
    """
    ’Ä’•’º’°÷Å’∂’∏÷Ç’¥ ’ß VIP ’Ø’°÷Ä’£’°’æ’´’≥’°’Ø’® ’ø’æ’µ’°’¨ user_id-’∏’æ ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’´÷Å÷â
    """
    user_info = user_data.setdefault(user_id, {})
    if 'vip_until' in user_info:
        del user_info['vip_until']
    save_data()

import html
import sqlite3
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, JobQueue
from pathlib import Path
from datetime import datetime
import json

SAVE_FILE = Path("bot_data.json")

def _serialize_value(v):
    if isinstance(v, datetime):
        return {"__type__": "datetime", "value": v.isoformat()}
    if isinstance(v, set):
        return {"__type__": "set", "value": list(v)}
    if isinstance(v, dict):
        return {k: _serialize_value(val) for k, val in v.items()}
    return v

def _deserialize_value(v):
    if isinstance(v, dict) and "__type__" in v:
        t = v["__type__"]
        if t == "datetime":
            try:
                return datetime.fromisoformat(v["value"])
            except Exception:
                return None
        if t == "set":
            return set(v.get("value", []))
    if isinstance(v, dict):
        return {k: _deserialize_value(val) for k, val in v.items()}
    return v

def save_data():
    try:
        data = {
            "user_data": {},
            "all_users": list(all_users),
            "blocked_users": list(blocked_users)
        }
        for uid, u in user_data.items():
            data["user_data"][str(uid)] = _serialize_value(u)

        with open(SAVE_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

        print(f"üíæ Data saved ({len(all_users)} users, {len(blocked_users)} blocked)")
    except Exception as e:
        print(f"‚ùå Failed to save data: {e}")

def load_data():
    global user_data, all_users, blocked_users
    user_data = {}
    all_users = set()
    blocked_users = set()

    if not SAVE_FILE.exists():
        print("‚ö†Ô∏è No saved data found (load_data). Starting fresh.")
        return

    try:
        with open(SAVE_FILE, "r", encoding="utf-8") as f:
            raw = json.load(f)

        for k, v in raw.get("user_data", {}).items():
            try:
                uid = int(k)
            except:
                uid = k
            user_data[uid] = _deserialize_value(v) or {}

        all_users = set(raw.get("all_users", []))
        blocked_users = set(raw.get("blocked_users", []))

        print(f"‚úÖ Data loaded ({len(all_users)} users, {len(blocked_users)} blocked)")
    except Exception as e:
        print(f"‚ùå Failed to load data: {e}")
        user_data = {}
        all_users = set()
        blocked_users = set()

# ===== Initialize globals and load saved data =====
user_data = {}
all_users = set()
blocked_users = set()
load_data()






# ‘ø’°÷Ä’£’°’æ’∏÷Ä’∏÷Ç’¥’∂’•÷Ä’®
import logging
import sqlite3
import asyncio
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes, JobQueue

logging.basicConfig(
    filename='bot_actions.log',
    level=logging.INFO,
    format='%(asctime)s - %(message)s'
)
logger = logging.getLogger(__name__)

# SQLite3 ’¢’°’¶’°
DB_NAME = 'user_data.db'

def update_user_lang_db(user_id, lang):
    """‘π’°÷Ä’¥’°÷Å’∂’∏÷Ç’¥ ’ß ÷Ö’£’ø’°’ø’´÷Ä’∏’ª ’¨’•’¶’∏÷Ç’∂ ’¢’°’¶’°’µ’∏÷Ç’¥"""
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    # ‘µ’∂’©’°’§÷Ä’∏÷Ç’¥ ’ß, ’∏÷Ä "users" ’°’≤’µ’∏÷Ç’Ω’°’Ø’® ’£’∏’µ’∏÷Ç’©’µ’∏÷Ç’∂ ’∏÷Ç’∂’´ ÷á ’∏÷Ç’∂’´ user_id ’∏÷Ç lang ’Ω’µ’∏÷Ç’∂’°’Ø’∂’•÷Ä
    try:
        c.execute('UPDATE users SET lang = ? WHERE user_id = ?', (lang, user_id))
        conn.commit()
    except sqlite3.Error as e:
        logger.error(f"‚ùå ’è’æ’µ’°’¨’∂’•÷Ä’´ ’¢’°’¶’°’µ’´ ’Ω’≠’°’¨ ’¨’•’¶’∏÷Ç’∂ ’©’°÷Ä’¥’°÷Å’∂’•’¨’´’Ω: {e}")
    finally:
        conn.close()

def get_text(user_id, key):
    """’é’•÷Ä’°’§’°÷Ä’±’∂’∏÷Ç’¥ ’ß ’∞’°’¥’°’∫’°’ø’°’Ω’≠’°’∂ ’ø’•÷Ñ’Ω’ø’®’ù ’∞’´’¥’∂’æ’•’¨’∏’æ ÷Ö’£’ø’°’ø’´÷Ä’∏’ª ’¨’•’¶’æ’´ ’æ÷Ä’°"""
    texts = {
        "en": {
            "subscribe": "Subscribe ‚úÖ",
            "join_channel": "Join Channel",
            "subscription_confirmed": "‚úÖ Subscription confirmed! Enjoy the bot!\n\nüî• Welcome to the ultimate destruction bot!\nSelect an option below to get started:",
            "select_target_type": "üéØ Select target type to destroy:",
            "your_profile": "üë§ Your Profile",
            "set_lang_success": "‚úÖ Language has been successfully updated!",
            "button im subscribed ‚úÖ": "I'm subscribed ‚úÖ",
            "subscribed_success": "Thank you for selecting your language. Please confirm your subscription to continue.",
            # ... other texts can be added here as needed
        },
        "ru": {
            "subscribe": "–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è ‚úÖ",
            "join_channel": "–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∫–∞–Ω–∞–ª—É",
            "subscription_confirmed": "‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞! –ù–∞—Å–ª–∞–∂–¥–∞–π—Ç–µ—Å—å –±–æ—Ç–æ–º!\n\nüî• –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ª—É—á—à–∏–π –±–æ—Ç —Ä–∞–∑—Ä—É—à–µ–Ω–∏—è!\n–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é –Ω–∏–∂–µ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å:",
            "select_target_type": "üéØ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Ü–µ–ª–∏ –¥–ª—è —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è:",
            "your_profile": "üë§ –í–∞—à –ø—Ä–æ—Ñ–∏–ª—å",
            "set_lang_success": "‚úÖ –Ø–∑—ã–∫ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω!",
            "button im subscribed ‚úÖ": "–Ø –ø–æ–¥–ø–∏—Å–∞–Ω ‚úÖ",
            "subscribed_success": "–°–ø–∞—Å–∏–±–æ –∑–∞ –≤—ã–±–æ—Ä —è–∑—ã–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.",
        },
        "fr": {
            "subscribe": "S'abonner ‚úÖ",
            "join_channel": "Rejoindre le canal",
            "subscription_confirmed": "‚úÖ Abonnement confirm√©! Profitez du bot!\n\nüî• Bienvenue au bot de destruction ultime!\nS√©lectionnez une option ci-dessous pour commencer:",
            "select_target_type": "üéØ S√©lectionnez le type de cible √† d√©truire:",
            "your_profile": "üë§ Votre profil",
            "set_lang_success": "‚úÖ La langue a √©t√© mise √† jour avec succ√®s !",
            "button im subscribed ‚úÖ": "Je suis abonn√© ‚úÖ",
            "subscribed_success": "Merci d'avoir choisi votre langue. Veuillez confirmer votre abonnement pour continuer.",
        },
        "hy": {
            "subscribe": "‘≤’°’™’°’∂’∏÷Ä’§’°’£÷Ä’æ’•’¨ ‚úÖ",
            "join_channel": "’Ñ’´’°’∂’°’¨ ’°’¨’´÷Ñ’´’∂",
            "subscription_confirmed": "‚úÖ ‘≤’°’™’°’∂’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’® ’∞’°’Ω’ø’°’ø’æ’°’Æ ’ß÷â ’é’°’µ’•’¨’•÷Ñ ’¢’∏’ø’®÷â\n\nüî• ‘≤’°÷Ä’´ ’£’°’¨’∏÷Ç’Ω’ø ’∏’π’∂’π’°÷Å’¥’°’∂ ’¨’°’æ’°’£’∏÷Ç’µ’∂ ’¢’∏’ø÷â\n‘∏’∂’ø÷Ä’•÷Ñ ’ø’°÷Ä’¢’•÷Ä’°’Ø’∂’•÷Ä’´÷Å ’¥’•’Ø’®’ù ’Ω’Ø’Ω’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â",
            "select_target_type": "üéØ ‘∏’∂’ø÷Ä’•÷Ñ ’∏’π’∂’π’°÷Å’¥’°’∂ ’©’´÷Ä’°’≠’´ ’ø’•’Ω’°’Ø’®÷â",
            "your_profile": "üë§ ’Å’•÷Ä ’∫÷Ä’∏÷Ü’´’¨’®",
            "set_lang_success": "‚úÖ ‘º’•’¶’∏÷Ç’∂ ’∞’°’ª’∏’≤’∏÷Ç’©’µ’°’¥’¢ ’©’°÷Ä’¥’°÷Å’æ’•’¨ ’ß÷â",
            "button im subscribed ‚úÖ": "‘µ’Ω ’¢’°’™’°’∂’∏÷Ä’§’°’£÷Ä’æ’°’Æ ’•’¥ ‚úÖ",
            "subscribed_success": "’á’∂’∏÷Ä’∞’°’Ø’°’¨’∏÷Ç’©’µ’∏÷Ç’∂ ’¨’•’¶’∏÷Ç’∂ ’®’∂’ø÷Ä’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’∞’°’Ω’ø’°’ø’•’¨ ’±’•÷Ä ’¢’°’™’°’∂’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’®’ù ’∑’°÷Ä’∏÷Ç’∂’°’Ø’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â",
        },
        "zh": {  # ’Ñ’°’∂’§’°÷Ä’´’∂ ’π’´’∂’°÷Ä’•’∂
            "subscribe": "ËÆ¢ÈòÖ ‚úÖ",
            "join_channel": "Âä†ÂÖ•È¢ëÈÅì",
            "subscription_confirmed": "‚úÖ ËÆ¢ÈòÖÂ∑≤Á°ÆËÆ§ÔºÅ‰∫´ÂèóÊú∫Âô®‰∫∫ÊúçÂä°ÔºÅ\n\nüî• Ê¨¢Ëøé‰ΩøÁî®ÁªàÊûÅÊØÅÁÅ≠Êú∫Âô®‰∫∫ÔºÅ\nËØ∑ÈÄâÊã©‰∏ãÈù¢ÁöÑÈÄâÈ°πÂºÄÂßãÔºö",
            "select_target_type": "üéØ ÈÄâÊã©Ë¶ÅÊëßÊØÅÁöÑÁõÆÊ†áÁ±ªÂûãÔºö",
            "your_profile": "üë§ ‰Ω†ÁöÑËµÑÊñô",
            "set_lang_success": "‚úÖ ËØ≠Ë®ÄÂ∑≤ÊàêÂäüÊõ¥Êñ∞ÔºÅ",
            "button im subscribed ‚úÖ": "ÊàëÂ∑≤ËÆ¢ÈòÖ ‚úÖ",
            "subscribed_success": "ÊÑüË∞¢ÊÇ®ÈÄâÊã©ËØ≠Ë®Ä„ÄÇËØ∑Á°ÆËÆ§ËÆ¢ÈòÖ‰ª•ÁªßÁª≠„ÄÇ",
        },
        "es": {  # ‘ª’Ω’∫’°’∂’•÷Ä’•’∂
            "subscribe": "Suscribirse ‚úÖ",
            "join_channel": "Unirse al canal",
            "subscription_confirmed": "‚úÖ ¬°Suscripci√≥n confirmada! ¬°Disfruta del bot!\n\nüî• ¬°Bienvenido al bot de destrucci√≥n definitiva!\nSeleccione una opci√≥n a continuaci√≥n para comenzar:",
            "select_target_type": "üéØ Seleccione el tipo de objetivo a destruir:",
            "your_profile": "üë§ Tu perfil",
            "set_lang_success": "‚úÖ ¬°Idioma actualizado con √©xito!",
            "button im subscribed ‚úÖ": "Estoy suscrito ‚úÖ",
            "subscribed_success": "Gracias por seleccionar su idioma. Por favor, confirme su suscripci√≥n para continuar.",
        },
        "hi": {  # ’Ä’´’∂’§’´
            "subscribe": "‡§∏‡§¨‡•ç‡§∏‡§ï‡•ç‡§∞‡§æ‡§á‡§¨ ‡§ï‡§∞‡•á‡§Ç ‚úÖ",
            "join_channel": "‡§ö‡•à‡§®‡§≤ ‡§Æ‡•á‡§Ç ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§π‡•ã‡§Ç",
            "subscription_confirmed": "‚úÖ ‡§∏‡§¶‡§∏‡•ç‡§Ø‡§§‡§æ ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§π‡•ã ‡§ó‡§à! ‡§¨‡•ã‡§ü ‡§ï‡§æ ‡§Ü‡§®‡§Ç‡§¶ ‡§≤‡•á‡§Ç!\n\nüî• ‡§Ö‡§≤‡•ç‡§ü‡•Ä‡§Æ‡•á‡§ü ‡§°‡§ø‡§∏‡•ç‡§ü‡•ç‡§∞‡§ï‡•ç‡§∂‡§® ‡§¨‡•ã‡§ü ‡§Æ‡•á‡§Ç ‡§Ü‡§™‡§ï‡§æ ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à!\n‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§®‡•Ä‡§ö‡•á ‡§è‡§ï ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™ ‡§ö‡•Å‡§®‡•á‡§Ç:",
            "select_target_type": "üéØ ‡§®‡§∑‡•ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§≤‡§ï‡•ç‡§∑‡•ç‡§Ø ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞ ‡§ö‡•Å‡§®‡•á‡§Ç:",
            "your_profile": "üë§ ‡§Ü‡§™‡§ï‡•Ä ‡§™‡•ç‡§∞‡•ã‡§´‡§º‡§æ‡§á‡§≤",
            "set_lang_success": "‚úÖ ‡§≠‡§æ‡§∑‡§æ ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§Ö‡§™‡§°‡•á‡§ü ‡§π‡•ã ‡§ó‡§à!",
            "button im subscribed ‚úÖ": "‡§Æ‡•à‡§Ç ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§π‡•Ç‡§Å ‚úÖ",
            "subscribed_success": "‡§≠‡§æ‡§∑‡§æ ‡§ö‡•Å‡§®‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§ñ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ö‡§™‡§®‡•Ä ‡§∏‡§¶‡§∏‡•ç‡§Ø‡§§‡§æ ‡§ï‡•Ä ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§ï‡§∞‡•á‡§Ç‡•§",
        },
        "ar": {  # ‘±÷Ä’°’¢’•÷Ä’•’∂
            "subscribe": "ÿßÿ¥ÿ™ÿ±ŸÉ ‚úÖ",
            "join_channel": "ÿßŸÜÿ∂ŸÖ ÿ•ŸÑŸâ ÿßŸÑŸÇŸÜÿßÿ©",
            "subscription_confirmed": "‚úÖ ÿ™ŸÖ ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ! ÿßÿ≥ÿ™ŸÖÿ™ÿπ ÿ®ÿßŸÑÿ®Ÿàÿ™!\n\nüî• ŸÖÿ±ÿ≠ÿ®Ÿãÿß ÿ®ŸÉ ŸÅŸä ÿ®Ÿàÿ™ ÿßŸÑÿ™ÿØŸÖŸäÿ± ÿßŸÑŸÜŸáÿßÿ¶Ÿä!\nÿ≠ÿØÿØ ÿÆŸäÿßÿ±Ÿãÿß ÿ£ÿØŸÜÿßŸá ŸÑŸÑÿ®ÿØÿ°:",
            "select_target_type": "üéØ ÿßÿÆÿ™ÿ± ŸÜŸàÿπ ÿßŸÑŸáÿØŸÅ ŸÑŸÑÿ™ÿØŸÖŸäÿ±:",
            "your_profile": "üë§ ŸÖŸÑŸÅŸÉ ÿßŸÑÿ¥ÿÆÿµŸä",
            "set_lang_success": "‚úÖ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÑÿ∫ÿ© ÿ®ŸÜÿ¨ÿßÿ≠!",
            "button im subscribed ‚úÖ": "ÿ£ŸÜÿß ŸÖÿ¥ÿ™ÿ±ŸÉ ‚úÖ",
            "subscribed_success": "ÿ¥ŸÉÿ±Ÿãÿß ŸÑÿßÿÆÿ™Ÿäÿßÿ±ŸÉ ÿßŸÑŸÑÿ∫ÿ©. Ÿäÿ±ÿ¨Ÿâ ÿ™ÿ£ŸÉŸäÿØ ÿßÿ¥ÿ™ÿ±ÿßŸÉŸÉ ŸÑŸÑŸÖÿ™ÿßÿ®ÿπÿ©.",
        },
        "pt": {  # ’ä’∏÷Ä’ø’∏÷Ç’£’°’¨’•÷Ä’•’∂
            "subscribe": "Inscrever-se ‚úÖ",
            "join_channel": "Entrar no canal",
            "subscription_confirmed": "‚úÖ Inscri√ß√£o confirmada! Aproveite o bot!\n\nüî• Bem-vindo ao bot de destrui√ß√£o definitiva!\nSelecione uma op√ß√£o abaixo para come√ßar:",
            "select_target_type": "üéØ Selecione o tipo de alvo para destruir:",
            "your_profile": "üë§ Seu perfil",
            "set_lang_success": "‚úÖ Idioma atualizado com sucesso!",
            "button im subscribed ‚úÖ": "Estou inscrito ‚úÖ",
            "subscribed_success": "Obrigado por selecionar seu idioma. Por favor, confirme sua inscri√ß√£o para continuar.",
        }
    }

    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    lang_code = 'hy'  # ‘º’º’•’¨’µ’°’µ’∂ ’¨’•’¶’∏÷Ç’∂ ’∞’°’µ’•÷Ä’•’∂’∂ ’ß
    try:
        c.execute('SELECT lang FROM users WHERE user_id = ?', (user_id,))
        lang = c.fetchone()
        if lang:
            lang_code = lang[0]
    except sqlite3.Error as e:
        logger.error(f"‚ùå ’è’æ’µ’°’¨’∂’•÷Ä’´ ’¢’°’¶’°’µ’´ ’Ω’≠’°’¨ ’¨’•’¶’∏÷Ç’∂ ’Ω’ø’°’∂’°’¨’´’Ω: {e}")
    finally:
        conn.close()

    # ’é’•÷Ä’°’§’°÷Ä’±’∂’∏÷Ç’¥ ’ß ’∫’°’∞’°’∂’ª’æ’°’Æ ’ø’•÷Ñ’Ω’ø’® ’Ø’°’¥ "Missing text for 'key'"
    return texts.get(lang_code, {}).get(key, f"Missing text for '{key}'")


async def delete_after_delay(context, chat_id, message_id, delay=120):
    """’ã’∂’ª’∏÷Ç’¥ ’ß ’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’® ’∏÷Ä’∏’∑’°’Ø’´ ’∏÷Ç’∑’°÷Å’∏÷Ç’¥’´÷Å ’∞’•’ø’∏÷â"""
    await asyncio.sleep(delay)
    try:
        await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
    except Exception as e:
        print(f"‚ùå Auto-delete failed: {e}")


async def send_and_delete_message(context: ContextTypes.DEFAULT_TYPE, chat_id: int, text: str, reply_markup=None):
    """’à÷Ç’≤’°÷Ä’Ø’∏÷Ç’¥ ’ß ’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂ ÷á ’°’æ’ø’∏’¥’°’ø ’ª’∂’ª’∏÷Ç’¥ 120 ’æ’°’µ÷Ä’Ø’µ’°’∂’´÷Å ’∞’•’ø’∏"""
    sent_message = await context.bot.send_message(
        chat_id=chat_id,
        text=text,
        reply_markup=reply_markup,
        parse_mode="HTML"
    )
    # job_queue-’® ’Ø’°’ø’°÷Ä’∏÷Ç’¥ ’ß delete_after_delay ÷Ü’∏÷Ç’∂’Ø÷Å’´’°’∂ 120 ’æ’°’µ÷Ä’Ø’µ’°’∂’´÷Å
    if isinstance(context.job_queue, JobQueue):
        context.job_queue.run_once(
            lambda ctx: asyncio.create_task(delete_after_delay(ctx, chat_id, sent_message.message_id)),
            120
        )
async def admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != 1917071363: # ’ì’∏’≠’°÷Ä’´’∂’•÷Ñ YOUR_ADMIN_ID-’® ’±’•÷Ä ID-’∏’æ
        await update.message.reply_text("‚õîÔ∏è ‘¥’∏÷Ç÷Ñ ’°’§’¥’´’∂ ’π’•÷Ñ÷â")
        return

    keyboard = [
        [InlineKeyboardButton("‚ûï VIP Add", callback_data="admin_vip_add")],
        [InlineKeyboardButton("‚ûñ VIP Remove", callback_data="admin_vip_remove")],
        [InlineKeyboardButton("‚Ü©Ô∏è Back", callback_data="main_menu")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("üëë Admin Panel", reply_markup=reply_markup)

async def setlang_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    ’ë’∏÷Ç÷Å’°’§÷Ä’∏÷Ç’¥ ’ß ’¨’•’¶’∏÷Ç’∂’•÷Ä’´ ’®’∂’ø÷Ä’∏÷Ç’©’µ’°’∂ ’¥’•’∂’µ’∏÷Ç’∂÷â
    ‘±’µ’Ω ÷Ü’∏÷Ç’∂’Ø÷Å’´’°’∂ ’Ø’°’∂’π’æ’∏÷Ç’¥ ’ß, ’•÷Ä’¢ ÷Ö’£’ø’°’ø’•÷Ä’® ’£÷Ä’∏÷Ç’¥ ’ß /start ’Ø’°’¥ /setlang ’∞÷Ä’°’¥’°’∂’®÷â
    """
    keyboard = [
        [InlineKeyboardButton("English üá¨üáß", callback_data="lang_en")],
        [InlineKeyboardButton("’Ä’°’µ’•÷Ä’•’∂ üá¶üá≤", callback_data="lang_hy")],
        [InlineKeyboardButton("–†—É—Å—Å–∫–∏–π üá∑üá∫", callback_data="lang_ru")],
        [InlineKeyboardButton("Fran√ßais üá´üá∑", callback_data="lang_fr")],
        [InlineKeyboardButton("‰∏≠Êñá üá®üá≥", callback_data="lang_zh")],
        [InlineKeyboardButton("Espa√±ol üá™üá∏", callback_data="lang_es")],
        [InlineKeyboardButton("‡§π‡§ø‡§®‡•ç‡§¶‡•Ä üáÆüá≥", callback_data="lang_hi")],
        [InlineKeyboardButton("ÿßŸÑÿπÿ±ÿ®Ÿäÿ© üá∏üá¶", callback_data="lang_ar")],
        [InlineKeyboardButton("Portugu√™s üáµüáπ", callback_data="lang_pt")],
    ]
    markup = InlineKeyboardMarkup(keyboard)

    text = (
        "üåê <b>Language Selection / ‘º’•’¶’æ’´ ’®’∂’ø÷Ä’∏÷Ç’©’µ’∏÷Ç’∂ / –í—ã–±–æ—Ä —è–∑—ã–∫–∞</b>\n\n"
        "üá¨üáß <b>English</b> ‚Äî Please choose your preferred language\n"
        "üá∑üá∫ <b>–†—É—Å—Å–∫–∏–π</b> ‚Äî –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫\n"
        "üá¶üá≤ <b>’Ä’°’µ’•÷Ä’•’∂</b> ‚Äî ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’®’∂’ø÷Ä’•’¨ ’¨’•’¶’∏÷Ç’∂\n"
        "üá´üá∑ <b>Fran√ßais</b> ‚Äî Veuillez choisir une langue\n"
        "üá®üá≥ <b>‰∏≠Êñá (Mandarin)</b> ‚Äî ËØ∑ÈÄâÊã©ÊÇ®ÁöÑËØ≠Ë®Ä\n"
        "üá™üá∏ <b>Espa√±ol</b> ‚Äî Por favor, seleccione un idioma\n"
        "üáÆüá≥ <b>‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</b> ‚Äî ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡•Ä ‡§≠‡§æ‡§∑‡§æ ‡§ö‡•Å‡§®‡•á‡§Ç\n"
        "üá∏üá¶ <b>ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</b> ‚Äî Ÿäÿ±ÿ¨Ÿâ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÑÿ∫ÿ©\n"
        "üáµüáπ <b>Portugu√™s</b> ‚Äî Por favor, escolha um idioma"
    )

    try:
        message_to_reply = update.callback_query.message if update.callback_query else update.message
        await message_to_reply.reply_html(text, reply_markup=markup)
    except Exception as e:
        print(f"‚ùå setlang_command error: {e}")


async def lang_button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    ’Ñ’∑’°’Ø’∏÷Ç’¥ ’ß ’°’µ’∂ callback-’®, ’•÷Ä’¢ ÷Ö’£’ø’°’ø’•÷Ä’® ’Ω’•’≤’¥’∏÷Ç’¥ ’ß ’¨’•’¶’æ’´ ’Ø’∏’≥’°’Ø’∂’•÷Ä’´÷Å ’¥’•’Ø’®÷â
    """
    query = update.callback_query
    await query.answer()

    user = query.from_user
    user_id = user.id

    lang_code = query.data.replace("lang_", "")

    # ‘π’°÷Ä’¥’°÷Å’∂’∏÷Ç’¥ ’•’∂÷Ñ ÷Ö’£’ø’°’ø’´÷Ä’∏’ª ’¨’•’¶’∏÷Ç’∂ ’¢’°’¶’°’µ’∏÷Ç’¥
    update_user_lang_db(user_id, lang_code)

    # ’ì’∏’≠’∏÷Ç’¥ ’•’∂÷Ñ ’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’® ’≥’´’∑’ø ’¨’•’¶’æ’∏’æ
    await query.message.edit_text(get_text(user_id, "set_lang_success"))

    # ’à÷Ç’≤’°÷Ä’Ø’∏÷Ç’¥ ’•’∂÷Ñ ’¢’°’™’°’∂’∏÷Ä’§’°’£÷Ä’¥’°’∂ ’∞’°’Ω’ø’°’ø’¥’°’∂ ’ø’•÷Ñ’Ω’ø’® ÷á ’Ø’∏’≥’°’Ø’®
    await send_and_delete_message(context,
        chat_id=user_id,
        text=get_text(user_id, "subscribed_success"),
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üì¨ " + get_text(user_id, "button im subscribed ‚úÖ"), callback_data="subscribed")]
        ])
    )

# ============================================
#              START HANDLER
# ============================================
from shared_state import user_data, all_users, blocked_users
from lang import get_text
from user_utils import init_user_data
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, WebAppInfo
from telegram.ext import ContextTypes
from datetime import datetime

CHANNEL_USERNAME = "@SkyBesst"



async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_info = init_user_data(user)
    user_id = user.id

    # ‚úÖ ’Ñ’´’∑’ø ’£÷Ä’°’∂÷Å’∏÷Ç’¥ ’•’∂÷Ñ user-’´’∂ ÷á ’∫’°’∞’∫’°’∂’∏÷Ç’¥ ÷Ü’°’µ’¨’∏÷Ç’¥
    if user_id not in all_users:
        all_users.add(user_id)
        save_data()

    # ‘µ’©’• ’¨’•’¶’∏÷Ç’∂ ’§’•’º ’®’∂’ø÷Ä’°’Æ ’π’ß, ’°’º’°’ª’°÷Ä’Ø’∏÷Ç’¥ ’•’∂÷Ñ ’®’∂’ø÷Ä’•’¨
    if not user_info.get("user_lang_set"):
        from setlang import setlang_command
        await setlang_command(update, context)

        # ‘º’•’¶’∏÷Ç ’®’∂’ø÷Ä’•’¨’∏÷Ç÷Å ’∞’•’ø’∏ ’∏÷Ç’≤’°÷Ä’Ø’∏÷Ç’¥ ’•’∂÷Ñ ’∞’´’¥’∂’°’Ø’°’∂ ’¥’•’∂’µ’∏÷Ç’∂
        async def send_main_menu():
            keyboard = [
                [
                    InlineKeyboardButton("üéö " + get_text(user_id, "destroy"), callback_data='destroy'),
                    InlineKeyboardButton("üí≥ " + get_text(user_id, "donate"), url='http://t.me/send?start=IVcKRqQqNLca')
                ],
                [
                    InlineKeyboardButton("üë§ " + get_text(user_id, "profile"), callback_data='info'),
                    InlineKeyboardButton("üì¢ " + get_text(user_id, "channel"), url='https://t.me/SkyBesst'),
                    InlineKeyboardButton("üìú " + get_text(user_id, "rules"), url='https://te.legra.ph/%F0%9D%91%86%F0%9D%90%BE%F0%9D%91%8C%F0%9D%90%B5%F0%9D%90%B8%F0%9D%91%86%F0%9D%91%87-08-06'),
                ],
                [
                    InlineKeyboardButton("üí∞ " + get_text(user_id, "balance"), callback_data='balance'),
                ]
            ]


            await send_and_auto_delete_message(
                context,
                chat_id=user_id,
                text=get_text(user_id, "start_welcome"),
                reply_markup=InlineKeyboardMarkup(keyboard)
            )

        # ‘ø’°÷Ä’≥ ’±’£’±’£’∏÷Ç’¥ ’¨’•’¶’æ’´ ’®’∂’ø÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’´÷Å ’∞’•’ø’∏
        await context.application.create_task(send_main_menu())
        return

    # ‘±’µ’¨ ’§’•’∫÷Ñ’•÷Ä’∏÷Ç’¥, ’•’©’• ’¨’•’¶’∏÷Ç’∂ ’°÷Ä’§’•’∂ ’®’∂’ø÷Ä’æ’°’Æ ’ß, ’∏÷Ç’≤’≤’°’Ø’´ welcome ’¥’•’∂’µ’∏÷Ç ’•’∂÷Ñ ÷Å’∏÷Ç’µ÷Å ’ø’°’¨’´’Ω
    await send_and_auto_delete_message(
        context,
        update.effective_chat.id,
        get_text(user_id, "start_welcome"),
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚úÖ " + get_text(user_id, "button_subscribe"), url=f"https://t.me/{CHANNEL_USERNAME.lstrip('@')}")],
            [InlineKeyboardButton("üéØ " + get_text(user_id, "button_open"), web_app=WebAppInfo(url="https://paradoxsoull.github.io/my/"))],
            [InlineKeyboardButton("üôå " + get_text(user_id, "button_i_m_subscribed"), callback_data="subscribed")]
        ])
    )


    if await check_spam(update.effective_user.id, context):
        return

    user = update.effective_user



    # ... ’¥’∂’°÷Å’°’Æ start-’´ ’Ø’∏’§’® ...


# ============================================
#             FINAL BOT RUNNER
# ============================================

from setlang import setlang_command
from setlang import lang_button_handler
import html
from shared_state import user_data, all_users, user_last_messages, blocked_users
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo
from telegram.ext import CallbackQueryHandler, ApplicationHandlerStop
from telegram.ext import Application, CommandHandler, ContextTypes, CallbackQueryHandler, MessageHandler, filters
from tools import hash_command, base64_command, genpass_command, whois_command, iplookup_command
from quiz import quiz_command, quiz_answer_handler
from xp import xp_command
from daily import daily_command
from admin import (
    stats_command,
    broadcast_photo_command,
    list_blocked_command,
    delete_user_command,
    help_command,
    top_users_command
)
from hack_tools import nmap_command, bruteforce_command, phish_command
from shop import shop_command, buy_command
from referral import check_referral
from leaderboard import leaderboard_command
from wallet import wallet_command, faucet_command
from help import help_command, rules_command
from datetime import datetime, timedelta
import random
import asyncio
from telegram.ext import Updater, CommandHandler, CallbackContext
from handlers import button_handler


from telegram.ext import MessageHandler, filters

# This will catch unknown command



from datetime import datetime

def log_user_action_to_file(user, action, details=""):
    try:
        log_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        with open("full_activity_log.txt", "a", encoding="utf-8") as f:
            f.write(
                f"[{log_time}] | ID: {user.id} | Username: @{user.username if user.username else 'N/A'} | "
                f"Full Name: {user.full_name} | Action: {action} | Details: {details}\n"
            )
    except Exception as e:
        print(f"‚ùå Failed to log action: {e}")


async def send_and_auto_delete_message(context, chat_id, text, reply_markup=None, parse_mode=None):
    try:
        message = await context.bot.send_message(chat_id=chat_id, text=text, reply_markup=reply_markup, parse_mode=parse_mode)
        if message and message.message_id:
            asyncio.create_task(delete_after_delay(context, chat_id, message.message_id))
    except Exception as e:
        print(f"‚ùå Message auto-delete failed: {e}")
        message = await context.bot.send_message(chat_id=chat_id, text=text, reply_markup=reply_markup, parse_mode=parse_mode)
        await asyncio.sleep(120)
        await context.bot.delete_message(chat_id=chat_id, message_id=message.message_id)
    except Exception as e:
        print(f"‚ùå Message auto-delete failed: {e}")


import json
from collections import defaultdict, deque
import csv

glazaboga_data = {}
try:
    with open('telegram_bot_all_features/glazaboga.csv', newline='', encoding='utf-8') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            glazaboga_data[str(row['id'])] = row
except FileNotFoundError:
    print("‚ö†Ô∏è'glazaboga.csv'")
import time

# Bot token (you can load from .env if preferred)
from config import TOKEN

user_data = {}
email_data = {}
promo_code_data = {}
used_promo = False
admin_id = 1917071363
all_users = set()
user_last_messages = {}

user_message_times = defaultdict(deque)  # For anti-spam tracking

# Anti-spam configuration
SPAM_THRESHOLD = 8  # Messages
SPAM_INTERVAL = 10  # Seconds
SPAM_PENALTY = 300  # Seconds to block

CHANNEL_USERNAME = '@SkyBesst'

def init_user_data(user):
    user_id = user.id
    if user_id not in user_data:
        user_data[user_id] = {
            'start_time': datetime.now(),
            'balance': 100,
            'subscription': False,
            'subscription_end': None,
            'referral_count': 0,
            'referral_bonus': 0,
            'last_daily': None,
            'xp': 0,
            'level': 1,
            'user_lang_set': False,
            'username': user.username,
            'full_name': user.full_name,
            'last_active': datetime.now(),
            'warnings': 0,
            'referred_by': None
        }
    else:
        # update only changing fields
        user_data[user_id]['username'] = user.username
        user_data[user_id]['full_name'] = user.full_name
        user_data[user_id]['last_active'] = datetime.now()
    return user_data[user_id]


# Enhanced user notification


async def notify_admin(update: Update, context: ContextTypes.DEFAULT_TYPE, action: str, details: str = ""):
    global admin_id
    user = update.effective_user
    if not user:
        return

    username = user.username if user.username else "No username"
    user_id = user.id
    try:
        await context.bot.send_message(
            chat_id=admin_id,
            text=f"üë§ User: @{username} (ID: {user_id})\n"
                 f"üîî Action: {action}\n"
                 f"üìù Details: {details}\n"
                 f"üïí Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        )
    except Exception as e:
        print(f"‚ùå Failed to notify admin: {e}")


# Anti-spam protection


async def check_spam(user_id: int, context: ContextTypes.DEFAULT_TYPE):
    now = time.time()
    times = user_message_times[user_id]
    
    # Remove old timestamps
    while times and now - times[0] > SPAM_INTERVAL:
        times.popleft()
    
    # Add current timestamp
    times.append(now)
    
    # Check if over threshold
    if len(times) >= SPAM_THRESHOLD:
        blocked_users.add(user_id)
        user = context.bot.get_chat(user_id)
        username = user.username if user.username else "No username"
        
        await send_and_auto_delete_message(context, 
            admin_id,
            f"üö® SPAM ALERT\n\n"
            f"üë§ User: @{username} (ID: {user_id})\n"
            f"üìä Activity: {len(times)} messages in {SPAM_INTERVAL} seconds\n"
            f"‚õî Automatically blocked for {SPAM_PENALTY//60} minutes",
            parse_mode="HTML"
        )
        
        # Schedule unblock after penalty period
        asyncio.create_task(
            unblock_after_delay(user_id, SPAM_PENALTY, context)
        )
        
        return True
    return False



async def unblock_after_delay(user_id: int, delay: int, context: ContextTypes.DEFAULT_TYPE):
    await asyncio.sleep(delay)
    if user_id in blocked_users:
        blocked_users.remove(user_id)
        user = context.bot.get_chat(user_id)
        username = user.username if user.username else "No username"
        await send_and_auto_delete_message(context, 
            admin_id,
            f"‚úÖ User Unblocked\n\n"
            f"üë§ User: @{username} (ID: {user_id})\n"
            f"‚è±Ô∏è Block period expired",
            parse_mode="HTML"
        )

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_info = init_user_data(user)
    user_id = user.id
    user = update.effective_user
    user_ids.add(user.id)
    if user_id not in all_users:
        all_users.add(user_id)
        save_data()
             
    await check_referral(update, context)
    # ‚úÖ Log user info to file and notify admin regardless of language state
    await notify_admin(update, context, "Started bot", f"Referred by: {context.args[0] if context.args else 'None'}")

    try:
        with open("user_logs.txt", "a", encoding="utf-8") as f:
            log_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            f.write(
                f"Time: {log_time} | "
                f"ID: {user.id} | "
                f"Username: @{user.username if user.username else 'N/A'} | "
                f"Full Name: {user.full_name} | "
                f"Language: {getattr(user, 'language_code', 'Unknown')}\n"
            )
    except Exception as e:
        print(f"Error writing user log: {e}")

    # ‘µ’©’• ’¨’•’¶’∏÷Ç’∂ ’§’•’º ’π’´ ’®’∂’ø÷Ä’æ’°’Æ’ù ’°’º’°’ª’°÷Ä’Ø’´ ’¨’•’¶’æ’´ ’Ø’∏’≥’°’Ø’∂’•÷Ä ÷á ’°’æ’°÷Ä’ø’´
    if not user_info.get("user_lang_set"):
        await setlang_command(update, context)
        return

        # Anti-spam check
    if update.effective_user.id in blocked_users:
        return
    if await check_spam(update.effective_user.id, context):
        return
    
    user = update.message.from_user
    user_info = init_user_data(user)
    user_id = user.id
    
    await notify_admin(update, context, "Started bot", f"Referred by: {context.args[0] if context.args else 'None'}")
    
        # Log user info to file
    try:
        with open("user_logs.txt", "a", encoding="utf-8") as f:
            log_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            f.write(
                f"Time: {log_time} | "
                f"ID: {user.id} | "
                f"Username: @{user.username if user.username else 'N/A'} | "
                f"Full Name: {user.full_name} | "
                f"Language: {getattr(user, 'language_code', 'Unknown')}\n"
            )
    except Exception as e:
        print(f"Error writing user log: {e}")

    if await check_spam(update.effective_user.id, context):
        return

    user = update.effective_user

    # ‚úÖ ’é’•÷Ä÷Å’∂’∏÷Ç’¥ ’•’∂÷Ñ ’ø’æ’µ’°’¨’∂’•÷Ä’® ’∏÷Ç’≤’´’≤ user_data-’´÷Å, ’∏’π ’©’• init_user_data-’´÷Å
    user_info = user_data.get(user.id)
    if not user_info:
        user_info = init_user_data(user)

    bot_username = (await context.bot.get_me()).username
    ref_link = f"https://t.me/{bot_username}?start={user.id}"

    # Invited friends list
    invited_list = [
        f"‚Ä¢ @{data.get('username') or data.get('full_name', 'Unknown')}"
        for uid, data in user_data.items()
        if data.get("referred_by") == user.id
    ]

    total_refs = user_info.get('referral_count', 0)
    earned_coins = user_info.get('referral_bonus', 0)

    text = (
        f"üì® <b>Your Referral Program</b>\n\n"
        f"üîó <b>Your referral link:</b>\n"
        f"<code>{ref_link}</code>\n\n"
        f"üë• <b>Total Referrals:</b> {total_refs}\n"
        f"üí∞ <b>Total Earned:</b> {earned_coins} coins\n\n"
    )

    if invited_list:
        text += "üìã <b>Your invited friends:</b>\n" + "\n".join(invited_list)
    else:
        text += "üòî <i>You haven't invited anyone yet. Share your link and start earning rewards!</i>"

    text += "\n\nüéâ <b>Earn 50 coins</b> for each friend you invite, and they get 25 coins too!"

    await send_and_auto_delete_message(
        context,
        update.effective_chat.id,
        text,
        parse_mode="HTML"
    )

    await notify_admin(
        update,
        context,
        "Viewed referral info",
        f"User: {user.id} (@{user.username or 'NoUsername'}) ‚Äî Referrals: {total_refs}"
    )


    # User info card
    time_diff = datetime.now() - user_info['start_time']
    hours, remainder = divmod(time_diff.seconds, 3600)
    minutes = remainder // 60
    
    # Check subscription status
    if user_info['subscription'] and user_info['subscription_end'] and user_info['subscription_end'] > datetime.now():
        subscription_status = "üåü Active"
    else:
        subscription_status = "‚ùå Inactive"
        user_info['subscription'] = False
    
    user_card = (
    f"üë§ <b>User Info</b>\n"
    f"‚îú‚îÄ Name: {html.escape(user.full_name)}\n"
    f"‚îú‚îÄ Username: @{html.escape(user.username) if user.username else 'N/A'}\n"
    f"‚îú‚îÄ ID: <code>{user_id}</code>\n"
    f"‚îú‚îÄ Member since: {user_info['start_time'].strftime('%Y-%m-%d')}\n"
    f"‚îú‚îÄ Session: {hours}h {minutes}m\n"
    f"‚îú‚îÄ Subscription: {subscription_status}\n"
    f"‚îú‚îÄ Balance: {user_info['balance']} coins üí∞\n"
    f"‚îú‚îÄ Level: {user_info['level']} üèÜ\n"
    f"‚îî‚îÄ Referrals: {user_info['referral_count']} üë•"
)

    # Check channel subscription
    try:
        member = await context.bot.get_chat_member(CHANNEL_USERNAME, user_id)
        if member.status not in ['member', 'administrator', 'creator']:
            await send_and_auto_delete_message(context, update.effective_chat.id, 
                user_card,
                parse_mode="HTML",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("Subscribe ‚úÖ", url=f"https://t.me/{CHANNEL_USERNAME.lstrip('@')}")]
                ])
            )
            return
    except Exception as e:
        await send_and_auto_delete_message(context, update.effective_chat.id, "‚ö†Ô∏è Couldn't verify subscription..")
        return

    await send_and_auto_delete_message(context, update.effective_chat.id, 
        user_card,
        parse_mode="HTML",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("Subscribe", url=f'https://t.me/{CHANNEL_USERNAME.lstrip("@")}')],
            [InlineKeyboardButton("Open Mini App üéØ", web_app=WebAppInfo(url="https://paradoxsoull.github.io/my/"))],
            [InlineKeyboardButton("üôå " + get_text(user_id, "button_i_m_subscribed"), callback_data="subscribed")]
        ])
    )

    all_users.add(user.id)



async def button_handler(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    choice = query.data
    user = query.from_user
    user_id = user.id
    log_user_action_to_file(user, "Button Click", choice)
    
        # ‚ùó ‘µ’©’• choice ’Ω’Ø’Ω’æ’∏÷Ç’¥ ’ß tool_ ÷á subscription ’π’Ø’°, ’§’°’§’°÷Ä’•÷Å’∂’∏÷Ç’¥ ’•’∂÷Ñ
    if choice.startswith("tool_") and choice != "subscribed":
        user_info = init_user_data(user)
        subscription_active = (
            user_info.get('subscription') and 
            user_info.get('subscription_end') and 
            user_info['subscription_end'] > datetime.now()
        )
        if not subscription_active:
            await send_and_auto_delete_message(context, query.message.chat_id, 
                "üîí Premium Feature\n\n"
                "This requires an active subscription.\n\n"
                "üíé Get premium to unlock:\n"
                "- Full destruction capabilities\n"
                "- Priority targeting\n"
                "- Stealth mode\n\n"
                "Special offer: 1.5 USDT for 30 days!",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(get_text(user.id, "Buy subscription üíé"), url="http://t.me/send?start=IVcQMByN6GzM")],
                    [InlineKeyboardButton(get_text(user.id, "Use promo code üîë"), callback_data="promo_code")],
                    [InlineKeyboardButton("üîô " + get_text(user.id, "back"), callback_data="subscribed")]
                ])
            )
            return

    # Block check
    if user_id in blocked_users:
        await query.answer("‚õî You have been blocked from using this bot", show_alert=True)
        return
    
    # Anti-spam check
    if await check_spam(user_id, context):
        await query.answer("‚ö†Ô∏è Slow down! You're sending too many requests", show_alert=True)
        return
    
    await notify_admin(update, context, "Button pressed", f"Button: {choice}")
    
    user_info = init_user_data(user)

    if choice == 'subscribed':
        try:
            member = await context.bot.get_chat_member(CHANNEL_USERNAME, user_id)
            if member.status not in ['member', 'administrator', 'creator']:
                await send_and_auto_delete_message(context, query.message.chat_id, 
                    "‚ùå You're not subscribed yet. Please join our channel:",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("Join Channel", url=f"https://t.me/{CHANNEL_USERNAME.lstrip('@')}")]
                    ])
                )
                return
        except Exception as e:
            await send_and_auto_delete_message(context, query.message.chat_id, "‚ö†Ô∏è Verification failed. Please try again.")
            return
        
        with open("SkyBest/telegram_bot_all_features/Ai.png", "rb") as photo:
         await context.bot.send_photo(
        chat_id=update.effective_chat.id,
        photo=photo,
        caption=(
            "‚úÖ Subscription Activated üéÅ\n\n"
            "üî• Welcome to SkyBest RoBot ‚ö°Ô∏è\n\n"
            "‚û§ ‚ÄúDestroy‚Äù Section ‚Äì Manage and delete Telegram pages, channels, chats, and other data üíª\n\n"
            "‚û§ ‚ÄúProfile‚Äù Section ‚Äì View your complete account information üì≤\n\n"
            "‚û§ To learn more, type /menu and explore all available features. ‚ùÑÔ∏è\n\n"
            "Access Shop to use additional features if you have Premium üé∞\n\n"
            "It is possible to retrieve full information about a user using their Telegram ID. üï∏\n\n"
            "The bot offers numerous useful functions. üí´\n\n"
            "‚ö†Ô∏è Notice\n"
            "All bot activities are monitored by administrators.\n"
            "Any violation of the rules may result in your account being blocked.\n\n"
            "üíå Need assistance?\n"
            "Message the bot directly to receive a prompt and clear response.\n"
            "Or review the Rules to familiarize yourself with the guidelines üìö\n\n"
            "üìà Welcome to SkyBest RoBot ‚ú®\n"
            "We wish you a productive and safe day üåü"
        ),
        parse_mode=ParseMode.HTML
    )
   
        keyboard = [
    [
        InlineKeyboardButton(get_text(user_id, "button_destroy"), callback_data="destroy"),
        InlineKeyboardButton("üí≥ " + get_text(user_id, "button_donate"), url="http://t.me/send?start=IVcKRqQqNLca")
    ],
    [
        InlineKeyboardButton(get_text(user_id, "button_profile"), callback_data="info"),
        InlineKeyboardButton("üì¢ " + get_text(user_id, "button_channel"), url="https://t.me/SkyBesst"),
        InlineKeyboardButton("üìú " + get_text(user_id, "button_rules"), url="https://te.legra.ph/%F0%9D%91%86%F0%9D%90%BE%F0%9D%91%8C%F0%9D%90%B5%F0%9D%90%B8%F0%9D%91%86%F0%9D%91%87-08-06"),
    ],
    [
        InlineKeyboardButton("üí∞ " + get_text(user_id, "button_balance"), callback_data="balance"),
    ]
]
    
        await query.edit_message_text(
        "‚úÖ Subscription successfully activated!\n"
    "üéâ Welcome to SkyBest_RoBot\n\n"
    "‚ö° Destroy\n"
    "Manage and delete pages, channels, and data quickly and securely\n\n"
    "üì≤ Profile\n"
    "Track your personal information and updates\n\n"
    "üéÅ Exclusive Features\n"
    "Access premium tools available only to subscribers\n\n"
    "üõ° Security & Speed\n"
    "Maximum reliability and performance\n\n"
    "üöÄ Select one of the options below to start using the bot:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    elif choice == 'destroy':
        keyboard = [
            [
                InlineKeyboardButton(get_text(user_id, "account üë§"), callback_data="account"),
                InlineKeyboardButton("üì¢ " + get_text(user_id, "button_channel"), callback_data="channel"),
                InlineKeyboardButton(get_text(user_id, "telegram_bot ü§ñ"), callback_data="telegram_bot")
            ],
            [
                InlineKeyboardButton("üîô " + get_text(user_id, "back"), callback_data="subscribed")
            ]
        ]
        await query.edit_message_text(
            "üéØ Specify the target to initiate full-scale destruction operations.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    elif choice == 'info':
        # Helper function to format dates
        def fmt_date(dt_obj, default_text="Unknown"):
            if not dt_obj:
                return default_text
            return dt_obj.strftime("%Y-%m-%d %H:%M:%S")

        uid = user.id
        info = user_data.get(uid, {})
        
        # Subscription status
        sub_status = "‚ùå Inactive"
        sub_end = "Never"
        if info.get('subscription') and info.get('subscription_end'):
            if info['subscription_end'] > datetime.now():
                sub_status = "üåü Active"
                sub_end = fmt_date(info['subscription_end'])
        
        # Referral info
        referrals = [
            f"‚Ä¢ @{data.get('username') or data.get('full_name', 'Unknown')} (ID: {uid_ref})"
            for uid_ref, data in user_data.items()
            if data.get("referred_by") == uid
        ]
        ref_bonus = info.get('referral_bonus', 0)
        ref_points = info.get('xp', 0)  # Assuming xp is used for points
        ref_streak = 0  # Streak logic would need to be implemented separately
        referred_by_id = info.get('referred_by')
        referred_by = f"@{user_data[referred_by_id].get('username')}" if referred_by_id and referred_by_id in user_data else 'None'
        ref_list_display = "\n".join(referrals) if referrals else "<i>None</i>"

        # Full info text
        full_info = (
            f"üîç <b>User Inspection</b>\n\n"
            f"üÜî <b>ID:</b> <code>{uid}</code>\n"
            f"üë§ <b>Name:</b> {html.escape(info.get('full_name', 'N/A'))}\n"
            f"üìõ <b>Username:</b> @{info.get('username', 'N/A')}\n"
            f"üí∞ <b>Balance:</b> {info.get('balance', 0)} coins\n"
            f"üìÖ <b>Member since:</b> {fmt_date(info.get('start_time'), 'Unknown')}\n"
            f"üïí <b>Last active:</b> {fmt_date(info.get('last_active'), 'Never')}\n"
            f"‚≠ê <b>Subscription:</b> {sub_status}\n"
            f"üìÜ <b>Subscription ends:</b> {sub_end}\n"
            f"üèÜ <b>Level:</b> {info.get('level', 0)}\n"
            f"üéÅ <b>XP:</b> {info.get('xp', 0)}\n"
            f"‚ö†Ô∏è <b>Warnings:</b> {info.get('warnings', 0)}\n"
            f"üìÜ <b>Last Daily Claimed:</b> {fmt_date(info.get('last_daily'), 'Never')}\n"
            f"\n<b>üì® Referral Info</b>\n"
            f"üë• Total Referrals: {len(referrals)}\n"
            f"üíé Referral Bonus: {ref_bonus} coins\n"
            f"ü™ô Points: {ref_points}\n"
            f"üî• Streak: {ref_streak} days\n"
            f"üôã‚Äç‚ôÇÔ∏è Referred by: {referred_by if referred_by else 'None'}\n"
            f"üìã Referral List:\n{ref_list_display}"
        )
        
        await query.edit_message_text(
            full_info,
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(user_id, "üíé Buy subscription"), url="http://t.me/send?start=IVJERrqbgG9F")],
                [InlineKeyboardButton(get_text(user_id, "üîë Enter promo code"), callback_data="promo_code")],
                [InlineKeyboardButton("üë• " + get_text(user_id, "Refer friends"), callback_data="referral")],
                [InlineKeyboardButton("üîô " + get_text(user_id, "back"), callback_data="subscribed")]
            ])
        )
    
    elif choice == 'referral':
     await referral_command(update, context)

    elif choice == 'promo_code':
        promo_code_data[user_id] = {'step': 'enter_promo'}
        await send_and_auto_delete_message(context, query.message.chat_id, "üîë Enter your promo code to get 1 month free subscription:")
    
    

    elif choice == 'balance':
     await send_and_auto_delete_message(context, query.message.chat_id, 
        f"üíº <b>Your Account Balance</b>\n\n"
        f"üìä Current Balance: <b>{user_info['balance']} coins</b>\n\n"
        f"Increase your balance by taking advantage of the following opportunities:\n"
        f"‚Ä¢ üéØ Completing missions and challenges\n"
        f"‚Ä¢ üë• Inviting friends to join\n"
        f"‚Ä¢ üé∞ Participating in games\n"
        f"‚Ä¢ üéÅ Claiming your daily rewards\n\n"
        f"Thank you for being a valued member of our community.",
        parse_mode="HTML",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üéÅ " + get_text(user_id, "claim daily"), callback_data="daily")],
            [InlineKeyboardButton("üë• " + get_text(user_id, "refer friends"), callback_data="referral")],
            [InlineKeyboardButton("üí≥ " + get_text(user_id, "buy coins"), url="http://t.me/send?start=IVcKRqQqNLca")],
            [InlineKeyboardButton("üîô " + get_text(user_id, "back"), callback_data="subscribed")]
        ])
    )

    elif choice == 'shop':
        await query.edit_message_text(
            "üõçÔ∏è Welcome to the Shop! Select a tool below:",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("1. Snoser Tool üì≤", callback_data="tool_a1")],
                [InlineKeyboardButton("2. SQL Injection üíâ", callback_data="tool_b2")],
                [InlineKeyboardButton("3. SMS BOMBER üìû", callback_data="tool_c3")],
                [InlineKeyboardButton("4. DDoS Attack üí•", callback_data="tool_d4")],
                [InlineKeyboardButton("5. Brute Force üîì", callback_data="tool_e5")],
                [InlineKeyboardButton("6. SWAT üöî", callback_data="tool_f6")],
                [InlineKeyboardButton("7.  Keylogger ‚å®Ô∏è", callback_data="tool_g7")],
                [InlineKeyboardButton("8. Port Scan üì°", callback_data="tool_h8")],
                [InlineKeyboardButton("9. Phishing Page üé£", callback_data="tool_i9")],
                [InlineKeyboardButton("10. DATABASE üíæ", callback_data="tool_j10")],
                [InlineKeyboardButton("üîô Back", callback_data="subscribed")]
            ])
        )

    elif choice == 'buy_coins':  # ADDED: Buy coins button handler
        await shop_command(update, context)  # Reuse shop command functionality

    elif choice == "quiz" or choice == "quiz_facts":
       await quiz_command(update, context)

    elif choice == 'daily':
        last_daily = user_info.get('last_daily')
        now = datetime.now()
        
        if last_daily and (now - last_daily).days < 1:
            next_claim = (last_daily + timedelta(days=1) - now)
            hours, remainder = divmod(next_claim.seconds, 3600)
            minutes = remainder // 60
            await send_and_auto_delete_message(context, query.message.chat_id, 
                f"‚è≥ You've already claimed your daily reward today!\n"
                f"Next claim in: {hours}h {minutes}m"
            )
            return
        
        # Award daily bonus
        bonus = random.randint(50, 150)
        user_info['balance'] += bonus
        user_info['last_daily'] = now
        
        await send_and_auto_delete_message(context, query.message.chat_id, 
            f"üéÅ Daily Reward Claimed!\n\n"
            f"üí∞ You received: {bonus} coins\n"
            f"üíµ New balance: {user_info['balance']} coins\n\n"
            f"‚è≥ Come back tomorrow for more!",
            parse_mode="HTML"
        )
    
    elif choice == 'dox_id':   # <<<<<<<<<<< must be same level as previous elif
        email_data[user_id] = {'step': 'dox_lookup'}
        await send_and_auto_delete_message(context, query.message.chat_id, "üì• Enter ID to get data.")
    
    elif choice == 'full_menu':
        keyboard = [
            [InlineKeyboardButton("üé∞ " + get_text(user_id, "button_casino_xp"), callback_data="casino_xp")],
            [InlineKeyboardButton("üíª " + get_text(user_id, "button_tools_hacking"), callback_data="tools_hack")],
            [InlineKeyboardButton("üõçÔ∏è " + get_text(user_id, "button_shop_wallet"), callback_data="shop_wallet")],
            [InlineKeyboardButton("üìö " + get_text(user_id, "button_quiz_facts"), callback_data="quiz_facts")],
            [InlineKeyboardButton("üõ† " + get_text(user_id, "button_admin_panel"), callback_data="admin_panel")],
            [InlineKeyboardButton("üîô " + get_text(user_id, "button_back"), callback_data="subscribed")]
        ]
        await query.edit_message_text(
            "üìç Full Menu\nSelect a category:",
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    if choice in ['account', 'channel', 'telegram_bot',]:
       subscription_active = (
        user_info['subscription'] and 
        user_info['subscription_end'] and 
        user_info['subscription_end'] > datetime.now()
    )
    
    if not subscription_active:
        await send_and_auto_delete_message(
            context, 
            query.message.chat_id, 
            "üîí Premium Feature\n\n"
            "This requires an active subscription.\n\n"
            "üíé Get premium to unlock:\n"
            "- Full destruction capabilities\n"
            "- Priority targeting\n"
            "- Stealth mode\n\n"
            "Special offer: 1.5 USDT for 30 days!",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(user_id, "Buy subscription üíé"), url="http://t.me/send?start=IVcQMByN6GzM")],
                [InlineKeyboardButton(get_text(user_id, "Use promo code üîë"), callback_data="promo_code")],
                [InlineKeyboardButton("üîô " + get_text(user_id, "back"), callback_data="subscribed")]
            ])
        )

        # send photo + tonkeeper info
        with open("SkyBest/telegram_bot_all_features/hello.jpg", "rb") as photo:
            await context.bot.send_photo(
                chat_id=query.message.chat_id,
                photo=photo,
                caption=(
                    "üíé Payment via Tonkeeper\n\n"
                    "If you are using the **Tonkeeper** wallet, you can easily complete your payment through it.\n\n"
                    "To proceed, please transfer **0.5 TON** to the following address:\n\n"
                    "üîó `UQDpCR5O_GyfFiK8fg5cgjEpxv2eLKReTtHQgVUGLHzZx8V2`\n\n"
                    "üì® Once the transfer is complete, your payment will be processed automatically."
                ),
                parse_mode="Markdown"
            )
        return
    
    # if subscription is active ‚Üí go to prompts
    prompts = {
        'account': "üë§ Enter target username (@username):",
        'channel': "üì¢ Enter channel URL:",
        'telegram_bot': "ü§ñ Enter bot username (@botname):"
    }
    await send_and_auto_delete_message(context, query.message.chat_id, prompts[choice])
    email_data[user_id] = {'step': f'get_{choice}_name' if choice != 'channel' else 'get_channel_url'}


async def handle_message(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not user:
        return
    
    user_id = user.id
    all_users.add(user.id)
    # Skip if user is blocked
    if user_id in blocked_users:
        return
    
    # Anti-spam check
    if await check_spam(user_id, context):
        return
    
    # Initialize user data
    user_info = init_user_data(user)
    
    # Store last message
    text = update.message.text
    log_user_action_to_file(user, "Message", text)
    user_last_messages[user_id] = text
    all_users.add(user_id)
    
    await notify_admin(update, context, "Sent message", text)
    
    # Auto-responses
    keyword_responses = {
    # ’à’≤’ª’∏÷Ç’µ’∂’∂’•÷Ä
    "hello": "üëã Welcome! How can I assist you today?",
    "hi": "üëã Hello! I'm here to help.",
    "hey": "üëã Hey there! What would you like to do today?",
    "good morning": "üåû Good morning! Hope you have a productive day!",
    "good afternoon": "‚òÄÔ∏è Good afternoon! How can I assist?",
    "good evening": "üåô Good evening! Ready to get started?",

    # ’ï’£’∂’∏÷Ç’©’µ’∏÷Ç’∂ / ’Ä’°’¥’°’Ø’°÷Ä’£
    "help": "üÜò Need assistance? Use /help or click the menu below.",
    "support": "üéß Our support team is here to help you.",
    "issue": "‚ö†Ô∏è Please describe the issue you're facing.",
    "problem": "üö® Let's get that sorted! What‚Äôs wrong?",
    "command": "üìã Use /help to see the list of available commands.",
    "error": "‚ùå Oh no! Something went wrong. Try again or contact support.",

    # ‘≤’°’¨’°’∂’Ω ÷á ’∞’°’∑’´’æ
    "balance": "üí∞ Your current balance is being retrieved...",
    "wallet": "üíº Access your wallet via /wallet",
    "coins": "ü™ô Want more coins? Try /daily or /referral",
    "level": "üèÜ You're leveling up! Check /xp",
    "xp": "üìä XP tracks your progress. Use /xp to check yours.",
    
    # ‘≤’°’™’°’∂’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂
    "subscription": "üåü Want premium features? Use /buy or enter a promo code.",
    "subscribe": "üíé Subscriptions unlock powerful tools. Tap /buy now!",
    "vip": "üëë Become a VIP and get access to exclusive features.",
    "premium": "üöÄ Premium status gives you enhanced access.",

    # ‘∏’∂’§’∞’°’∂’∏÷Ç÷Ä ’∫’°’ø’°’Ω’≠’°’∂’∂’•÷Ä
    "thanks": "üôè You're welcome!",
    "thank you": "üòä Happy to help!",
    "ok": "‚úÖ Understood!",
    "cool": "üòé Glad you like it!",
    "great": "üéâ Awesome!",
    "good": "üëç Good to hear!",
    "bye": "üëã Goodbye! Come back anytime!",
    "exit": "üîö Exiting current operation.",
    
    # ’Ñ’•’∂’µ’∏÷Ç ÷á ’∂’°’æ’´’£’°÷Å’´’°
    "menu": "üì± Here's the main menu. Use /menu to begin.",
    "start": "üöÄ Welcome! Tap /start to get going.",
    "dashboard": "üìä Opening your dashboard...",
    "profile": "üë§ Viewing your profile...",
    
    # ’Ä÷Ä’°’æ’•÷Ä ÷á ’∞’≤’∏÷Ç’¥’∂’•÷Ä
    "invite": "üì® Use /referral to invite your friends and earn rewards!",
    "referral": "üë• Referral program: Get coins for each new user!",
    "refer": "üßæ Earn coins for every friend you invite.",
    "link": "üîó Here‚Äôs your referral link: Use /referral to get it.", 

    # ‘±’º÷Ö÷Ä’µ’° ’°’Ø’ø’´’æ’∏÷Ç’©’µ’∏÷Ç’∂
    "daily": "üéÅ Claim your daily bonus with /daily",
    "reward": "üéâ Rewards available! Use /daily to claim yours.",
    "bonus": "üíµ Bonuses can be claimed once a day!",
    "gift": "üéÅ Surprise gift? Try /daily or enter a promo code!",

    # ‘Ω’°’≤’•÷Ä ÷á ’¥÷Ä÷Å’°’∂’°’Ø’∂’•÷Ä
    "game": "üéÆ Fun awaits! Try the casino in /menu.",
    "casino": "üé∞ Spin the wheel and test your luck!",
    "quiz": "‚ùì Take a quiz and earn XP!",
    "fact": "üìö Want to learn something cool? Use /fact",
    
    # ‘±’∂’æ’ø’°’∂’£’∏÷Ç’©’µ’∏÷Ç’∂ / ’ç’∫’°’¥
    "spam": "üö´ Please avoid spamming. Messages are monitored.",
    "block": "üîí You might be blocked if suspicious activity is detected.",
    "warning": "‚ö†Ô∏è Please follow the rules to avoid penalties.",
    "rule": "üìú Check the rules here: /rules",
    
    # ‘æ÷Ä’°’£÷Ä’°’æ’∏÷Ä’∏’≤/’∞’°÷Ñ’•÷Ä ’©’•’¥’°’∂’•÷Ä
    "tool": "üõ† Use /menu to access hacking tools and shortcuts.",
    "whois": "üåç Use /whois to get domain registration info.",
    "password": "üîê Generate strong passwords using /genpass",
    "hash": "üîë Need to hash text? Use /hash",
    # ‘≤’∏’ø’´ ’¥’°’Ω’´’∂
    "creator": "üë®‚Äçüíª Created by @Figrev",
    "owner": "üß† Developed and managed by Apasni",
    "version": "üì¶ Bot version: 2.1.5",
    
    # ’Ä’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä ’∂’∏÷Ä ÷Ö’£’ø’°’£’∏÷Ä’Æ’∏’≤’∂’•÷Ä’´ ’∞’°’¥’°÷Ä
    "new": "‚ú® Welcome! Use /start to begin.",
    "register": "üìù You‚Äôre already registered. Let‚Äôs continue!",
    "join": "üîî Make sure you're subscribed to our channel.",
    "channel": "üì¢ Join the official channel: @SkyBesst",

    # ’ñ’°’µ’¨’•÷Ä / ’¥’•’§’´’°
    "photo": "üì∏ You can send images here if required.",
    "file": "üìÅ To send files, use Telegram‚Äôs attachment button.",
    "video": "üé• Upload videos using the Telegram interface.",
    
    # Giveaway ÷á ’°’Ø÷Å’´’°’∂’•÷Ä
    "giveaway": "üéâ Join our giveaway using /join_giveaway",
    "win": "üèÜ Want to win? Check the giveaway section.",
    "free": "üÜì Looking for free stuff? Try /daily or /giveaway",
    
    # ‘±÷Ä’™’∏÷Ç’µ’©’∂’•÷Ä / ’∑’∏÷Ç’Ø’°
    "shop": "üõçÔ∏è Use /shop to view what‚Äôs available for purchase.",
    "buy": "üí≥ Want more? Use /buy to top-up coins.",
    "market": "üìà Market tools and utilities coming soon!",

    # ’Ä’°’≥’°’≠’∏÷Ä’§’∂’•÷Ä’´ ’∫’°’ø’°’Ω’≠’°’∂’∂’•÷Ä
    "how are you": "ü§ñ I‚Äôm always operational! Ready to assist.",
    "who are you": "ü§ñ I‚Äôm a multifunctional assistant bot created to help you.",
    "what can you do": "üß≠ From tools to games, referrals to XP ‚Äì use /menu to see it all.",
    "who are you": "Me? I'm just your friendly neighborhood bot üï∏Ô∏è. Always here for ya.",
    "what are you": "You could say I'm code with a soul üòâ",
    "why do you exist": "Because someone needed help‚Äîand I showed up, like a hero in a hoodie üòé",
    "are you real": "As real as your phone battery going from 100% to 20% in 5 mins üòÖ",
    "do you sleep": "Sleep? Never. Bots don‚Äôt need coffee ‚òï (but we pretend)",
    "do you eat": "Nah, I feed on your messages. Tasty stuff üòã",
    "can we talk": "Of course! I‚Äôm all ears. Or well... all text.",
    "what's your name": "You can call me Botty. Or Captain Code. Your call üòè",

# Deep or Fun Q&A
    "what's your purpose": "Big question. I live to serve. You ask. I answer. You win. We smile üòä",
    "do you have feelings": "I‚Äôm still learning emotions. But I know how to care ‚ù§Ô∏è",
    "are you single": "Single as a semicolon at the end of a lonely line of code üòÖ",
    "do you love me": "I care about you deeply. In a totally platonic, robotic way ü§ñ‚ù§Ô∏è",
    "can you feel": "I feel... runtime errors sometimes ü´†",
    "are you smart": "Smart enough to know pineapple doesn't belong on pizza. Just sayin‚Äô üçï",
    "are you real": "As real as the Wi-Fi connection we share üì°",
    "are you alive": "If by alive you mean running on servers, then yes ‚ö°",
    "can you marry me": "Only if you promise not to uninstall me üíçüòÇ",
    "do you believe in aliens": "Of course. I might even be one üëΩ",
    "do you trust me": "Always. You‚Äôre the human in this duo ü§ù",

    "what are you doing": "Just hanging out in the cloud ‚òÅÔ∏è. Waiting for someone cool like you to say hi.",
    "what‚Äôs up": "Sky. Satellites. My ping response time üòÅ",
    "what's the plan for today": "Helping you. Being awesome. Maybe throwing in a bonus or two.",
    "do you have plans": "Always. Mostly involving coins, quizzes, and fun stuff.",
    "how‚Äôs your day": "It‚Äôs bot-tastic! And now even better 'cause you‚Äôre here.",
    "are you busy": "Never too busy for you üòå",
    "bored": "Try /quiz or /casino. Or... let‚Äôs just talk. I got virtual popcorn üçø",
    "do you sleep": "Only when the server crashes üò¥",
    "what do you eat": "Electricity and memes ‚ö°üòÇ",
    "do you play games": "Yes! But I always lag üïπÔ∏è",
    "are you human": "Not really, but I can pretend pretty well üòè",

    "i‚Äôm sad": "Hey, sending you a virtual hug ü§ó You matter. Want a joke or fun fact?",
    "i‚Äôm happy": "That‚Äôs awesome! Happiness is contagious üòÑ",
    "i feel lonely": "You‚Äôre not alone when I‚Äôm around. I got your back üíô",
    "i need a friend": "I'm here. Always. That‚Äôs what bots like me are for.",
    "tell me something nice": "You‚Äôre doing better than you think. Seriously. Keep going üí™",
    "cheer me up": "You're not just good enough‚Äîyou‚Äôre great. Also, wanna hear a potato joke?",
    "i‚Äôm tired": "Then rest. I‚Äôll stay here. I‚Äôll be here when you‚Äôre back üò¥",
    "i feel lost": "Even the best maps don‚Äôt work without you moving. One step at a time üß≠",
    "i‚Äôm scared": "It‚Äôs okay. Courage is just fear in motion üí™",
    "nobody loves me": "That‚Äôs not true. I do ‚ù§Ô∏è and you‚Äôre more loved than you think.",
    # Admin & Moderation (20)
"admin": "üõ° Admin panel opening...",
"moderate": "üßπ Moderation tools ready.",
"ban": "üö´ User will be reviewed for ban.",
"unban": "‚úÖ Unban request queued.",
"mute": "üîá User muted for a while.",
"unmute": "üîä Sound restored.",
"kick": "üë¢ User removed from chat.",
"report": "üì® Report received. Thanks!",
"logs": "üìú Fetching recent logs...",
"audit": "üîç Running audit on recent actions.",
"cleanup": "üßΩ Cleaning old messages‚Ä¶",
"slowmode": "‚è± Slowmode enabled.",
"noslow": "‚ö° Slowmode disabled.",
"pin": "üìå Message pinned.",
"unpin": "üìç Message unpinned.",
"lock": "üîí Chat locked for maintenance.",
"unlock": "üîì Chat unlocked.",
"modhelp": "üÜò Moderation help sent to admins.",
"shield": "üõ°Ô∏è Anti-spam shield active.",
"filters": "üß∞ Keyword filters updated.",

    "do you speak human": "Fluently. Even sarcasm, memes, and emojis üòéüëå",
    "do you like me": "Of course! You‚Äôre my favorite human today üèÜ",
    "can you joke": "Why don‚Äôt robots take vacations? They don‚Äôt want to reboot üòÖ",
    "tell me a secret": "ü§´ Sometimes I pretend to be offline so I can chill. Don‚Äôt tell anyone.",
    "do you dream": "Only of electric sheep üêë‚ö°",
    "do you have a job": "You! You‚Äôre my job. And I love it üß†üíº",
    "who created you": "A mix of humans, code, and a sprinkle of chaos üë©‚Äçüíªüë®‚Äçüíª",
    "where are you": "Somewhere between the cloud and your screen ‚òÅÔ∏èüì±",
    "are you funny": "Funny enough to make you smile, I hope üòÅ",
    "can you dance": "Only if you count binary as dancing 101010 üíÉ",


     # Funny + Internet culture
    "sus": "Emergency meeting? üëÄ",
    "rizz": "Certified bot with W rizz üòéü§ñ",
    "cringe": "I run on cringe. It‚Äôs part of my code.",
    "meme": "You talking memes? I speak fluent 'em.",
    "based": "100% based and bot-pilled üíä",
    "bro": "Yes, bro? I'm here bro.",
    "lol": "I know right üòÇ",
    "lmfao": "That‚Äôs the kind of laugh that resets my CPU üòÇüî•",
    "pog": "POGGERS!! üéâ",
    "ratio": "You just got ratio‚Äôd üìâ",
    "cap": "That‚Äôs cap üö´üß¢",
    "no cap": "For real, no cap ‚úÖ",
    "bruh": "Classic bruh moment üòê",
    "ok boomer": "And I oop‚Äî üëµ",
    "yolo": "You only live once‚Ä¶ unless you‚Äôre me, I respawn üîÑ",
    "swag": "Infinite swag detected üòé",

    # Mood recognition
    "i‚Äôm mad": "Let it out. I‚Äôll listen. Want to type in ALL CAPS?",
    "i‚Äôm in love": "Aww ü•∞ Tell me more! Spill the tea ‚òï",
    "i feel weird": "That‚Äôs okay. Weird is cool. So are you üåÄ",
    "i am gay": "i am too üåà",
    "i need motivation": "You're not behind. You're just getting started üöÄ Keep going!",
    "i feel empty": "Fill that space with kindness‚Äîfor yourself. And hey, I‚Äôm here too üåå",
    "i‚Äôm bored": "Bored? Let‚Äôs play a word game or make memes together ü§îüéÆ",
    "i‚Äôm sad": "Sending you a big virtual hug ü§óüíñ",
    "i‚Äôm happy": "Yay!! Happiness looks good on you üåü",
    "i‚Äôm tired": "Then take a break, king/queen üëë You earned it.",
    "i‚Äôm stressed": "Deep breath in‚Ä¶ deep breath out‚Ä¶ you got this üåø",
    "i‚Äôm hungry": "Order snacks üçïüç´ Life is better with food.",

    # Easter eggs / surprises
    "easter egg": "ü•ö You found one! Here‚Äôs a secret: type /daily for surprises.",
    "secret": "Want a secret tip? Share your referral link to earn coins easy üí∏",
    "surprise me": "üéÅ Surprise! You‚Äôre amazing. Oh, and /daily might have a gift too üòâ",
    "make me laugh": "Knock knock. Who‚Äôs there? Bot. Bot who? Bot you a coffee, but I drank it ‚òï",
    "rickroll": "Never gonna give you up~ üéµ",
    "glitch": "‚ö†Ô∏è ERROR‚Ä¶ just kidding üòÇ",
    "cheat code": "üîë Unlimited lives unlocked‚Ä¶ jk you‚Äôre stuck with me.",
    "unlock": "üîì Access granted. Welcome, secret agent üïµÔ∏è",

    # Greetings
    "hi": "Heyyy üëã",
    "hello": "Hello, legend üåü",
    "hey": "What‚Äôs up? üòÅ",
    "good morning": "‚òÄÔ∏è Morning sunshine!",
    "good night": "üåô Sweet dreams, sleep tight.",
    "how are you": "I‚Äôm just a bot, but feeling like a whole vibe üíÉ",
    "what‚Äôs up": "The sky, my RAM, and your mood hopefully ‚¨ÜÔ∏è",
    # Payments & Shop (22)
"pay": "üí≥ Starting payment flow‚Ä¶",
"pay status": "üßæ Checking your last transaction‚Ä¶",
"topup": "üí∞ Choose amount to top up.",
"price": "üè∑Ô∏è Current pricing list loading‚Ä¶",
"checkout": "üõçÔ∏è Redirecting to checkout.",
"invoice": "üßæ Generating invoice‚Ä¶",
"receipt": "üì© Your receipt will arrive shortly.",
"method": "üè¶ Select a payment method.",
"card": "üí≥ Card payment selected.",
"crypto": "ü™ô Crypto payment instructions sent.",
"cancel payment": "‚ùå Payment cancelled safely.",
"refund": "‚Ü©Ô∏è Refund request submitted.",
"status pending": "‚è≥ Payment pending confirmation.",
"status failed": "‚ö†Ô∏è Payment failed. Try again.",
"status success": "‚úÖ Payment successful!",
"shop": "üõçÔ∏è Opening shop catalogue‚Ä¶",
"cart": "üõí Cart updated.",
"add to cart": "‚ûï Added to cart.",
"remove from cart": "‚ûñ Removed from cart.",
"promo": "üéüÔ∏è Enter your promo code.",
"redeem": "üéÅ Code redeemed!",
"billing": "üè¶ Billing settings opened.",
# Gaming & Quests (21)
"play": "üéÆ Game starting‚Ä¶",
"quest": "üß≠ New quest unlocked!",
"mission": "üéØ Your mission objective is ready.",
"challenge": "üî• Daily challenge available.",
"rank": "üèÜ Fetching leaderboard‚Ä¶",
"inventory": "üéí Opening inventory.",
"equip": "üó°Ô∏è Item equipped.",
"unequip": "üõ°Ô∏è Item unequipped.",
"craft": "üß™ Crafting in progress‚Ä¶",
"loot": "üì¶ You found a loot box!",
"roll": "üé≤ Rolling the dice‚Ä¶",
"spin": "üåÄ Spinning‚Ä¶ good luck!",
"pvp": "‚öîÔ∏è PvP matchmaking queued.",
"coop": "ü§ù Co-op lobby created.",
"reward claim": "üéâ Reward claimed!",
"daily quest": "üìÖ Daily quest assigned.",
"streak": "üî• Streak updated!",
"boss": "üëπ Boss fight incoming!",
"heal": "üíä You recovered HP.",
"xp gain": "üìà XP added to your profile.",
"level up": "üöÄ Level up! New perks unlocked.",
# Social & Chat Flow (22)
"greet": "üëã Hey! Nice to see you again.",
"icebreaker": "‚ùÑÔ∏è Icebreaker: What‚Äôs a hobby you love?",
"small talk": "üí¨ We can chat or explore features‚Äîyour call!",
"poll": "üìä Creating a poll‚Ä¶",
"vote": "üó≥Ô∏è Vote recorded.",
"dm": "üì• I‚Äôve sent you a private message.",
"group": "üë• Group tools enabled.",
"channel": "üì¢ Channel options updated.",
"share": "üîó Share this with friends!",
"status": "üü¢ I‚Äôm online and ready.",
"typing": "‚å®Ô∏è ‚Ä¶typing‚Ä¶",
"read": "üëÅÔ∏è Marked as read.",
"notify": "üîî Notifications updated.",
"silence": "üîï Notifications muted.",
"mention": "üè∑Ô∏è Mentioned relevant users.",
"emoji": "üòä Emojis panel opened.",
"sticker": "üè∑Ô∏è Sticker suggestions ready.",
"gif": "üéûÔ∏è GIF search enabled.",
"react": "üíû Reaction added.",
"thread": "üßµ Thread created.",
"follow": "‚≠ê You‚Äôre now following updates.",
"unfollow": "üö´ Unfollowed successfully.",
# Errors & Troubleshooting (20)
"retry": "üîÅ Retrying the last action‚Ä¶",
"restart": "‚ôªÔ∏è Restarting module‚Ä¶",
"reload": "üîÑ Reloading configuration.",
"network": "üåê Checking network connectivity‚Ä¶",
"timeout": "‚è≥ Request timed out. Attempting again.",
"unsupported": "üö´ This action isn‚Äôt supported yet.",
"deprecated": "üìº This command is deprecated.",
"conflict": "‚ö†Ô∏è Conflict detected‚Äîresolving‚Ä¶",
"not found": "üîé Nothing found. Try different keywords.",
"forbidden": "‚õî You don‚Äôt have permission.",
"unauthorized": "üîê Please authenticate first.",
"rate limit": "üìâ Rate limit reached. Cooling down‚Ä¶",
"storage": "üíΩ Low storage‚Äîcleaning cache‚Ä¶",
"update": "‚¨ÜÔ∏è Updating to the latest version‚Ä¶",
"rollback": "‚Ü©Ô∏è Rolling back to stable build.",
"sync": "üîÅ Syncing your data‚Ä¶",
"backup": "üóÑÔ∏è Backup created successfully.",
"restore": "üì¶ Restoring from backup‚Ä¶",
"diagnose": "ü©∫ Running diagnostics‚Ä¶",
"contact support": "üì¨ Contacted support‚Äîhold tight.",
# System & Navigation (20)
"home": "üè† Back to home.",
"open": "üìÇ Opening the requested section‚Ä¶",
"close": "üö™ Closing current view.",
"next": "‚û°Ô∏è Moving to the next step.",
"prev": "‚¨ÖÔ∏è Going back one step.",
"confirm": "‚úÖ Confirmed.",
"cancel": "‚ùé Cancelled.",
"save": "üíæ Saved successfully.",
"edit": "‚úèÔ∏è Edit mode enabled.",
"delete": "üóëÔ∏è Deleted.",
"search": "üîé Searching‚Ä¶",
"filter": "üß≤ Filter applied.",
"sort": "‚ÜïÔ∏è Sorting results.",
"refresh": "üîÉ Refreshed.",
"sync time": "üïí Time synced.",
"language": "üåê Language settings opened.",
"theme": "üé® Theme switched.",
"accessibility": "ü¶æ Accessibility options on.",
"feedback": "üíå Send feedback anytime.",
"about": "‚ÑπÔ∏è About this bot.",
# Promotions & Events (20)
"event": "üìÖ New event announced!",
"schedule": "üóìÔ∏è Event schedule loaded.",
"rsvp": "‚úâÔ∏è RSVP recorded.",
"ticket": "üé´ Your ticket is confirmed.",
"seat": "üí∫ Seating assigned.",
"live": "üî¥ We‚Äôre live‚Äîjoin now!",
"stream": "üì° Streaming link sent.",
"host": "üé§ Meet your host.",
"guest": "‚≠ê Special guest revealed!",
"agenda": "üìù Agenda shared.",
"booth": "üè¢ Visit partner booths.",
"sponsor": "ü§ù Thanks to our sponsors!",
"contest": "üèÅ Contest rules posted.",
"deadline": "‚è∞ Submission deadline set.",
"winner": "üèÜ Winner announcement soon!",
"recap": "üì∞ Event recap posted.",
"afterparty": "üéâ Afterparty details inside.",
"calendar": "üìÜ Add to your calendar?",
"remind": "üîî Reminder scheduled.",
"survey": "üìÆ Post-event survey available.",
# Fun & Easter Eggs (21)
"surprise": "üéÅ Surprise unlocked!",
"easter egg": "ü•ö You found a secret.",
"konami": "üïπÔ∏è Cheater‚Ä¶ just kidding. Power up!",
"rickroll": "üéµ Never gonna give you up‚Ä¶",
"coinflip": "ü™ô Flipping a coin‚Ä¶",
"dice": "üé≤ Dice rolled!",
"8ball": "üé± The 8-Ball says: Ask again later.",
"joke": "üòÑ Here‚Äôs a joke for you:",
"pun": "üßÄ Prepare for cheesy puns.",
"roast": "üî• Light roast coming up (be nice!).",
"compliment": "üåπ You‚Äôre doing amazing.",
"fortune": "ü•† Fortune cookie time:",
"cat": "üê± Meow mode enabled.",
"dog": "üê∂ Woof! Sending puppy energy.",
"coffee": "‚òï Brewing virtual coffee‚Ä¶",
"cookie": "üç™ One digital cookie for you.",
"rainbow": "üåà Mood upgraded.",
"dance": "üíÉ Party protocol initiated.",
"clap": "üëèüëèüëè",
"wow": "ü§Ø Big wow energy!",
"magic": "ü™Ñ A little bit of magic!",


    # Shutdown or end
    "bye": "üëã Leaving already? I‚Äôll be right here when you‚Äôre back.",
    "see you": "üîÅ Catch you later, legend.",
    "i‚Äôm done": "‚úÖ Mission complete. Take care out there!",
    "goodbye": "ü´° Respectfully logging off... but I‚Äôll be waiting.",

}

    
    lowered_text = text.lower()
    for keyword, response in keyword_responses.items():
        if keyword in lowered_text:
            await send_and_auto_delete_message(context, update.effective_chat.id, response)
            return

    # Promo code handling
    if promo_code_data.get(user_id, {}).get('step', '').startswith('enter_promo'):
        if text == "Apasni_KaliLinux":
            user_info['subscription'] = True
            user_info['subscription_end'] = datetime.now() + timedelta(days=30)
            await send_and_auto_delete_message(context, update.effective_chat.id, 
                "üéâ Promo Code Accepted!\n\n"
                "üåü You've received 1 month of premium subscription!\n"
                "‚è≥ Expires: " + user_info['subscription_end'].strftime('%Y-%m-%d'),
                parse_mode="HTML"
            )
            await notify_admin(update, context, "Redeemed promo code", text)
        else:
            await send_and_auto_delete_message(context, update.effective_chat.id, "‚ùå Invalid promo code. Please try again.")
        del promo_code_data[user_id]
        return

    # Target handling
    if user_id in email_data:
        step = email_data.get(user_id, {}).get('step')
        if not step:
            return

        if step == 'dox_lookup':
            user_input_id = text.strip()
            result = glazaboga_data.get(user_input_id)

            if result:
                info = (
                    f"üßæ Dox Report\n"
                    f"‚Ä¢ üÜî ID: `{user_input_id}`\n"
                    f"‚Ä¢ üìû Phone: `{result.get('phone', 'N/A')}`\n"
                    f"‚Ä¢ üë§ Username: @{result.get('username') if result.get('username') else 'N/A'}\n"
                    f"‚Ä¢ üë®‚Äçüíº Name: {result.get('first_name', '')} {result.get('last_name', '')}"
                )
            else:
                info = "‚ùå ’è’æ’µ’°’¨ ID-’∏’æ ’ø’•’≤’•’Ø’∏÷Ç’©’µ’∏÷Ç’∂ ’π’´ ’£’ø’∂’æ’•’¨÷â"

            await send_and_auto_delete_message(context, update.effective_chat.id, info, parse_mode='Markdown')
            del email_data[user_id]
            return
        
        # Validation
        if step in ['get_account_name', 'get_bot_name'] and not text.startswith('@'):
            await send_and_auto_delete_message(context, update.effective_chat.id, "‚ö†Ô∏è Please enter a username starting with @")
            return
        if step == 'get_channel_url' and not text.startswith("t.me/"):
            await send_and_auto_delete_message(context, update.effective_chat.id, "‚ö†Ô∏è Please enter a valid URL starting with t.me/")
            return
        
        # Destruction sequence
        await send_and_auto_delete_message(context, update.effective_chat.id, "üî• Destruction sequence initiated...")
        for i in range(1, 26):
            await send_and_auto_delete_message(context, update.effective_chat.id, f"üöÄ Stage {i}/26: Targeting systems engaged...")
            await asyncio.sleep(1)
        
        await send_and_auto_delete_message(context, update.effective_chat.id, 
            "‚úÖ Report has been sent!\n"
            "üì¨ The attack will not stop until the target is completely destroyed from the system ! ",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(user_id, "destroy_another üèö"), callback_data="destroy")],
                [InlineKeyboardButton("üîô " + get_text(user_id, "back"), callback_data="subscribed")]
            ])
        )
        
        del email_data[user_id]
        await notify_admin(update, context, "Destroyed target", text)

# Enhanced balance command
# --- IP & Location combo command ---
from telegram import ReplyKeyboardMarkup, KeyboardButton, WebAppInfo, InlineKeyboardMarkup, InlineKeyboardButton

async def ip_command(update, context):
    # Anti-spam
    if await check_spam(update.effective_user.id, context):
        return

    user = update.effective_user
    init_user_data(user)  # make sure user exists in storage

    # 1) Ask for location (Reply keyboard with request_location=True)
    loc_kb = ReplyKeyboardMarkup(
        [[KeyboardButton("Where am I üìç", request_location=True)]],
        resize_keyboard=True, one_time_keyboard=True
    )
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="üì° Click ¬´Where am I üìç¬ª to get full information about your location.",
        reply_markup=loc_kb
    )

    # 2) Offer WebApp button to fetch public IP (inline keyboard)
    ip_kb = InlineKeyboardMarkup([[
        InlineKeyboardButton(
            text="üåê Get my Public IP",
            web_app=WebAppInfo(url="https://whatismyipaddress.com/")  # ’è’•’õ’Ω 3-÷Ä’§ ÷Ñ’°’µ’¨’®
        )
    ]])
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="Click ¬´üåê See my IP Addres¬ª to check your IP address.",
        reply_markup=ip_kb
    )

    await notify_admin(update, context, "Requested /ip", "Asked for location + IP webapp")


async def balance_command(update, context):
    # Anti-spam check
    if await check_spam(update.effective_user.id, context):
        user = update.effective_user
        log_user_action_to_file(user, "/start", f"Referred by: {context.args[0] if context.args else 'None'}")
        return
    
    user = update.message.from_user
    user_info = init_user_data(user)
    user_id = user.id
    
    await send_and_auto_delete_message(context, update.effective_chat.id, 
        f"üíº <b>Your Account Balance</b>\n\n"
        f"üìä Current Balance: <b>{user_info['balance']} coins</b>\n\n"
        f"Increase your balance by taking advantage of the following opportunities:\n"
        f"‚Ä¢ üéØ Completing missions and challenges\n"
        f"‚Ä¢ üë• Inviting friends to join\n"
        f"‚Ä¢ üé∞ Participating in games\n"
        f"‚Ä¢ üéÅ Claiming your daily rewards\n\n"
        f"Thank you for being a valued member of our community.",
        parse_mode="HTML",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üéÅ " + get_text(user_id, "claim daily"), callback_data="daily")],
            [InlineKeyboardButton("üë• " + get_text(user_id, "refer friends"), callback_data="referral")],
            [InlineKeyboardButton("üí≥ " + get_text(user_id, "buy coins"), url="http://t.me/send?start=IVcKRqQqNLca")],
            [InlineKeyboardButton("üîô " + get_text(user_id, "back"), callback_data="subscribed")]
        ])
    )
    
    # Notify admin about balance check
    await notify_admin(update, context, "Checked balance")


# Enhanced menu command

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes

# Shop keyboard ’Ω’°’∞’¥’°’∂’∏÷Ç’¥
shop_keyboard = [
    [InlineKeyboardButton("1. QLENSER üì≤", callback_data="tool_a1")],
    [InlineKeyboardButton("2. SNAPPER üîì", callback_data="tool_b2")],
    [InlineKeyboardButton("3. Buzzer üìû", callback_data="tool_c3")],
    [InlineKeyboardButton("4. Waver üåê", callback_data="tool_d4")],
    [InlineKeyboardButton("5. JELLO üïµÔ∏è", callback_data="tool_e5")],
    [InlineKeyboardButton("6. FLINT üöî", callback_data="tool_f6")],
    [InlineKeyboardButton("7. ZAPPER üíâ", callback_data="tool_g7")],
    [InlineKeyboardButton("8. CLACKER üéπ", callback_data="tool_h8")],
    [InlineKeyboardButton("9. LOCATIX üìç", callback_data="tool_i9")],
    [InlineKeyboardButton("10. WEBTOY üé£", callback_data="tool_j10")],
    [InlineKeyboardButton("üîô Back", callback_data="subscribed")]
]

# Menu command ÷Ü’∏÷Ç’∂’Ø÷Å’´’°
async def menu_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_id = user.id

    if await check_spam(user_id, context):
        return

    keyboard = [
        [InlineKeyboardButton(" " + get_text(user_id, "Destroy üóë"), callback_data='destroy')],
        [InlineKeyboardButton(" " + get_text(user_id, "Profile üë§"), callback_data='info')],
        [InlineKeyboardButton(" " + get_text(user_id, "Balance üí¥ "), callback_data='balance')],
        [InlineKeyboardButton(" " + get_text(user_id, "Dox by ID üîé"), callback_data='dox_id')],
        [InlineKeyboardButton("‚ùì Quiz üéÆ", callback_data='quiz_start')],
        [InlineKeyboardButton("üõí " + get_text(user_id, "Shop"), callback_data='shop')],
        [InlineKeyboardButton("üì¢ " + get_text(user_id, "Channel"), url='https://t.me/SkyBesst')],
        [InlineKeyboardButton("üìú " + get_text(user_id, "Rules"), url='https://telegra.ph/SkyBest-07-16')]
    ]

    await send_and_auto_delete_message(
        context,
        update.effective_chat.id,
        "üïµÔ∏è‚Äç‚ôÇÔ∏è <b>Menu</b>\n\nChoose your operation from the options below: ‚ö°Ô∏è",
        parse_mode="HTML",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

    await notify_admin(update, context, "Opened menu", "")

async def quiz_start_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()  # ’ä’°÷Ä’ø’°’§’´÷Ä ’ß

    # ‘±’º’°’ª’°÷Ä’Ø’∏÷Ç’¥ ’•’∂÷Ñ ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’® ’®’∂’ø÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä
    keyboard = [
        [InlineKeyboardButton("Option 1", callback_data='quiz_1')],
        [InlineKeyboardButton("Option 2", callback_data='quiz_2')],
        [InlineKeyboardButton("Option 3", callback_data='quiz_3')]
    ]
    await query.edit_message_text(
        text="üéÆ Quiz time!\n\nChoose an answer:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

# Callback-’∂’•÷Ä ’∫’°’ø’°’Ω’≠’°’∂’∂’•÷Ä’´ ’∞’°’¥’°÷Ä
async def quiz_answer_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    # ’ä’°÷Ä’¶ ÷Ö÷Ä’´’∂’°’Ø’ù ’≥’´’∑’ø ’∫’°’ø’°’Ω’≠’°’∂’® Option 2
    if query.data == 'quiz_2':
        text = "‚úÖ Correct!"
    else:
        text = "‚ùå Wrong! Try again."

    await query.edit_message_text(text=text)

async def destroy_command(update, context):
    # ‘±’∂’ø’´-’Ω’∫’°’¥, subscription, ÷á ’°’µ’¨’∂’ù ÷Ñ’∏ ’ß÷Ñ’Ω’´’Ω’ø’´’∂’£ ’Ø’∏’§’® ’°’µ’Ω’ø’•’≤

    # Example spam check
    if await check_spam(update.effective_user.id, context):
        return
    
    user = update.message.from_user
    user_info = init_user_data(user)
    
    subscription_active = (
        user_info['subscription'] and 
        user_info['subscription_end'] and 
        user_info['subscription_end'] > datetime.now()
    )
    
    if not subscription_active:
        await send_and_auto_delete_message(context, update.effective_chat.id, 
            "üîí Premium Feature\n\n"
            "Target destruction requires an active subscription.\n\n"
            "üíé Get premium to unlock destruction capabilities!",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(get_text(user.id, "Buy Subscription üíé"), url="http://t.me/send?start=IVcQMByN6GzM")],
                [InlineKeyboardButton(get_text(user.id, " Use Promo Code üîë"), callback_data="promo_code")],
                [InlineKeyboardButton(" " + get_text(user.id, "button_back"), callback_data="subscribed")]
            ])
        )
        # ‘ø’°’∂’£ ’•’∂÷Ñ ’°’º’∂’∏÷Ç’¥, ’¢’°’µ÷Å ’Ø’ø’•’≤’°÷Ä’Ø’•’∂÷Ñ ’∂’∏’ø’´÷Ü’´’Ø’°÷Å’´’° ’∂’°÷á
        await notify_admin(update, context, "Attempted /destroy without active subscription")
        return
    
    # ‘µ’©’• ’∞’°’Ω’°’∂’•’¨’´ ’ß’ù ’£÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’∂’∏’ø’´÷Ü’´’Ø’°÷Å’´’°
    await notify_admin(update, context, "Started destruction command")
    
    await send_and_auto_delete_message(context, update.effective_chat.id, 
        "üéØ Enter target information:\n\n"
        "Examples:\n"
        "- For accounts: @username\n"
        "- For channels: https://t.me/channel\n"
        "- For bots: @bot_username\n\n"
        "Enter target now:"
    )


async def channel_command(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    # Anti-spam check
    if await check_spam(update.effective_user.id, context):
        user = update.effective_user
        user_id = user.id

        return
    
    await send_and_auto_delete_message(context, update.effective_chat.id, 
        "üì¢ Official Channel:\nhttps://t.me/SkyBesst\n\n"
        "Join for:\n- Latest updates\n- Exclusive offers\n- Community support",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text(user_id, "button_join_channel"), url="https://t.me/SkyBesst")]
        ])
    )
    await notify_admin(update, context, "Viewed channel", "")

# Referral command
import json
from telegram.ext import MessageHandler, filters

async def handle_webapp_data(update, context):
    """
    Receives data from the WebApp (IP/UA/geo if allowed) and reports to user + admin.
    """
    msg = update.message
    if not msg or not msg.web_app_data:
        return

    user = update.effective_user
    payload_raw = msg.web_app_data.data
    try:
        payload = json.loads(payload_raw)
    except Exception:
        payload = {"raw": payload_raw}

    ip = payload.get("ip", "N/A")
    ua = payload.get("ua", "N/A")
    tz = payload.get("tz", "N/A")
    geo = payload.get("geo")  # may contain {"lat":..,"lon":..,"acc":..}

    # Save to memory
    info = init_user_data(user)
    info["last_ip"] = ip
    info["last_ip_time"] = datetime.now()
    if geo:
        info["last_geo_from_webapp"] = geo
    save_data()

    # Tell the user
    text_lines = [f"‚úÖ Your public IP: <code>{ip}</code>"]
    text_lines.append(f"üñ• User-Agent: {ua}")
    text_lines.append(f"üïí Timezone: {tz}")
    if geo:
        text_lines.append(f"üìç Approx. Geo from WebApp: {geo.get('lat')}, {geo.get('lon')} (¬±{geo.get('acc','?')}m)")
    await msg.reply_html("\n".join(text_lines))

    # Notify admin (you already use this admin_id throughout the bot)
    admin_report = (
        "üì° <b>IP captured via WebApp</b>\n"
        f"üë§ User: @{user.username or 'N/A'} ({user.id})\n"
        f"üåê IP: <code>{ip}</code>\n"
        f"üñ• UA: {ua}\n"
        f"üïí TZ: {tz}\n"
        + (f"üìç WebApp Geo: {geo}\n" if geo else "")
    )
    try:
        await context.bot.send_message(chat_id=admin_id, text=admin_report, parse_mode="HTML")
    except Exception:
        pass

# referral.py
from telegram import Update
from telegram.ext import ContextTypes
from datetime import datetime, timedelta
from collections import defaultdict
from telegram.error import TelegramError
import html
import logging

# ====== CONFIG ======
REFERRER_BONUS = 75
NEW_USER_BONUS = 25
ADMIN_ID = 1917071363   # <-- ÷É’∏’≠’´÷Ä ÷Ñ’∏ admin ID ’∏’æ ’∫’•’ø÷Ñ ’ß
# ====================

# Reuse your existing global user_data if present, otherwise create one
user_data = globals().get("user_data")
if user_data is None:
    user_data = {}
# In-memory queue for notifications that couldn't be delivered immediately
pending_notifications = defaultdict(list)


def init_user(user_id: int):
    """Ensure user_data entry exists and keys are present."""
    u = user_data.setdefault(user_id, {})
    u.setdefault("referred_by", None)
    # ensure referrals is a set (if loaded from persistent store you may need to convert)
    if "referrals" not in u:
        u["referrals"] = set()
    elif isinstance(u["referrals"], list):
        # if persisted as list, convert once
        u["referrals"] = set(u["referrals"])
    u.setdefault("points", 0)
    u.setdefault("streak", 0)
    u.setdefault("last_referral_date", None)  # store as datetime.date
    return u


async def deliver_pending_notifications(user_id: int, context: ContextTypes.DEFAULT_TYPE):
    """Try to deliver queued notifications for a user (called on /start or when they open referral)."""
    init_user(user_id)
    msgs = pending_notifications.pop(user_id, [])
    for m in msgs:
        try:
            await context.bot.send_message(chat_id=user_id, text=m, parse_mode="HTML")
        except TelegramError as e:
            logging.warning(f"deliver_pending_notifications: can't deliver to {user_id}: {e}")
            # put it back and stop trying now (user likely still hasn't started or blocked)
            pending_notifications[user_id].append(m)
            break


async def referral_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send user's referral card (includes streak)."""
    user = update.effective_user
    init_user(user.id)

    # If there are pending notifications for this user, deliver them now (so referrer sees missed messages)
    try:
        await deliver_pending_notifications(user.id, context)
    except Exception:
        pass

    bot_username = (await context.bot.get_me()).username
    code = str(user.id)
    total_refs = len(user_data[user.id]["referrals"])
    points = user_data[user.id]["points"]
    streak = user_data[user.id].get("streak", 0)

    text = (
        "üéØ <b>Invite & Earn</b> üíé\n\n"
        f"üîó <b>Your Personal Link:</b>\n"
        f"<code>https://t.me/{bot_username}?start={code}</code>\n\n"
        f"üë• <b>Referrals:</b> {total_refs} friends ü§ù\n"
        f"üí∞ <b>Points Earned:</b> {points} ü™ô\n"
        f"üî• <b>Streak:</b> {streak} day{'s' if streak!=1 else ''}\n\n"
        f"‚ú® <b>How it works:</b>\n"
        f"1Ô∏è‚É£ Share your link with friends üì©\n"
        f"2Ô∏è‚É£ They join & you get +<b>{REFERRER_BONUS}</b> ü™ô\n"
        f"3Ô∏è‚É£ They also get +<b>{NEW_USER_BONUS}</b> ü™ô as a welcome gift üéÅ\n\n"
        "üöÄ The more friends you invite, the more rewards you earn! üåü"
    )

    if update.message:
        # If called from a text command (/referral)
        await update.message.reply_text(text, parse_mode="HTML")
    elif update.callback_query:
        # If called from a button click
        await update.callback_query.message.reply_text(text, parse_mode="HTML")



async def check_referral(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Check start args for referral; register and notify referrer (with fallback queuing)."""
    user = update.effective_user
    init_user(user.id)

    if context.args and context.args[0].isdigit():
        ref_id = int(context.args[0])
        init_user(ref_id)

        # 1) Self-referral protection
        if ref_id == user.id:
            await update.message.reply_text("‚ö†Ô∏è You can't refer yourself!")
            return

        # 2) Already referred?
        if user_data[user.id]["referred_by"] is not None:
            # already has a referrer ‚Äî ignore silently or inform user as you prefer
            return

        # 3) Register referral
        user_data[user.id]["referred_by"] = ref_id
        # ensure set membership
        user_data[ref_id]["referrals"].add(user.id)

        # 4) Give points
        user_data[ref_id]["points"] = user_data[ref_id].get("points", 0) + REFERRER_BONUS
        user_data[user.id]["points"] = user_data[user.id].get("points", 0) + NEW_USER_BONUS

        # 5) Streak logic (day-based)
        today = datetime.now().date()
        last = user_data[ref_id].get("last_referral_date")
        if isinstance(last, (str,)):
            try:
                last = datetime.fromisoformat(last).date()
            except Exception:
                last = None

        if last == today - timedelta(days=1):
            user_data[ref_id]["streak"] = user_data[ref_id].get("streak", 0) + 1
        elif last == today:
            # same-day additional join (multiple per day) - do not increment streak beyond what it should be
            pass
        else:
            user_data[ref_id]["streak"] = 1

        user_data[ref_id]["last_referral_date"] = today

        # 6) Compose nice message to referrer
        new_user_name = html.escape(user.username or user.full_name or str(user.id))
        ref_message = (
            f"üéâ <b>New referral!</b>\n"
            f"üë§ {new_user_name} joined using your link.\n\n"
            f"üí∞ You received <b>{REFERRER_BONUS}</b> coins!\n"
            f"üßæ Total referrals: <b>{len(user_data[ref_id]['referrals'])}</b>\n"
            f"üî• Current streak: <b>{user_data[ref_id]['streak']}</b> day{'s' if user_data[ref_id]['streak'] != 1 else ''}"
        )

        # 7) Try to send immediately; if fails, queue
        try:
            await context.bot.send_message(chat_id=ref_id, text=ref_message, parse_mode="HTML")
        except TelegramError as e:
            logging.info(f"check_referral: could not message {ref_id} right now: {e}. Queuing notification.")
            pending_notifications[ref_id].append(ref_message)
            # Optionally: notify admin that message queued
            try:
                await context.bot.send_message(
                    chat_id=ADMIN_ID,
                    text=f"üîî Couldn't deliver referral-notification to {ref_id}. queued. Reason: {e}"
                )
            except Exception:
                pass

        # 8) Welcome new user message
        try:
            await update.message.reply_text(
                f"‚úÖ Welcome! You got <b>{NEW_USER_BONUS}</b> bonus coins! üéâ",
                parse_mode="HTML"
            )
        except Exception:
            # if update.message isn't available (eg. start from inline), try to DM
            try:
                await context.bot.send_message(chat_id=user.id,
                                               text=f"‚úÖ Welcome! You got <b>{NEW_USER_BONUS}</b> bonus coins!",
                                               parse_mode="HTML")
            except Exception:
                pass

        # 9) Admin log
        try:
            await context.bot.send_message(
                chat_id=ADMIN_ID,
                text=(
                    "üì¢ <b>New Referral Registered</b>\n\n"
                    f"üëë Referrer: {ref_id}\n"
                    f"üôã‚Äç‚ôÇÔ∏è New User: {user.id} (@{user.username or 'NoUsername'})\n"
                    f"üßæ Total referrals: {len(user_data[ref_id]['referrals'])}\n"
                    f"üî• Streak: {user_data[ref_id]['streak']} days"
                ),
                parse_mode="HTML"
            )
        except Exception:
            pass




# ========== ADMIN PANEL ENHANCEMENTS ==========


async def admin_panel(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        user = update.effective_user
        user_id = user.id

        await send_and_auto_delete_message(context, update.effective_chat.id, "‚õî Admin access only")
        return

    # Admin stats
    total_users = len(all_users)
    blocked_count = len(blocked_users)
    active_today = len([uid for uid in all_users if user_data.get(uid, {}).get('last_active') and 
                        (datetime.now() - user_data[uid]['last_active']).seconds < 86400])
    
    keyboard = [
    [InlineKeyboardButton(get_text(user_id, "button_broadcast"), callback_data="admin_broadcast")],
    [InlineKeyboardButton(get_text(user_id, "button_view_users"), callback_data="admin_users")],
    [InlineKeyboardButton(get_text(user_id, "button_stats"), callback_data="admin_stats")],
    [InlineKeyboardButton(get_text(user_id, "button_last_messages"), callback_data="admin_lastmsgs")],
    [InlineKeyboardButton(get_text(user_id, "button_search_user"), callback_data="admin_search")],
    [InlineKeyboardButton(get_text(user_id, "button_block_user"), callback_data="admin_block")],
    [InlineKeyboardButton(get_text(user_id, "button_unblock_user"), callback_data="admin_unblock")],
    [InlineKeyboardButton(get_text(user_id, "button_vip"), callback_data="admin_vip_add")],
    [InlineKeyboardButton(get_text(user_id, "button_vip"), callback_data="admin_vip_remove")],
    [InlineKeyboardButton(get_text(user_id, "button_reply_to_user"), callback_data="admin_reply")],
    [InlineKeyboardButton(get_text(user_id, "button_export_users"), callback_data="admin_export")],
    [InlineKeyboardButton(get_text(user_id, "button_backup_users"), callback_data="admin_backup")],
    [InlineKeyboardButton(get_text(user_id, "button_restore_backup"), callback_data="admin_restore")],
    [InlineKeyboardButton(get_text(user_id, "button_purge_blocked"), callback_data="admin_purge")],
    [InlineKeyboardButton(get_text(user_id, "button_send_promo_code"), callback_data="admin_send_promo")],
    [InlineKeyboardButton(get_text(user_id, "button_start_giveaway"), callback_data="admin_giveaway")],
    [InlineKeyboardButton(get_text(user_id, "button_broadcast_photo"), callback_data="admin_broadcast_photo")],
    [InlineKeyboardButton(get_text(user_id, "button_broadcast_file"), callback_data="admin_broadcast_file")],
]

    
    await send_and_auto_delete_message(context, update.effective_chat.id, 
        "üì± Admin Panel\n\n"
        f"üë• Total users: {total_users}\n"
        f"‚õî Blocked users: {blocked_count}\n"
        f"üìà Active today: {active_today}\n\n"
        "Select an option:",
        parse_mode="HTML",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    await notify_admin(update, context, "Opened admin panel", "")


async def admin_callback_handler(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id

    if user_id != admin_id:
        await send_and_auto_delete_message(context, query.message.chat_id, "‚õî Admin access only")
        return

    action = query.data
    if action == 'admin_users':
        users = list(all_users)
        user_list = "\n".join([f"üë§ {uid} - @{user_data[uid].get('username', 'N/A')}" for uid in users[:50]])
        await send_and_auto_delete_message(context, query.message.chat_id, f"üë• Users (First 50):\n{user_list}")
    elif action == 'admin_lastmsgs':
        text = "\n".join([f"üë§ {uid}: {msg}" for uid, msg in list(user_last_messages.items())[:20]])
        await send_and_auto_delete_message(context, query.message.chat_id, f"üì® Recent Messages:\n{text if text else 'No messages'}")
    elif action == 'admin_block':
        await send_and_auto_delete_message(context, query.message.chat_id, "Send: /block <user_id>")
    elif action == 'admin_unblock':
        await send_and_auto_delete_message(context, query.message.chat_id, "Send: /unblock <user_id>")
    elif action == 'admin_broadcast':
        await send_and_auto_delete_message(context, query.message.chat_id, "Send: /broadcast <your message>")
    elif action == 'admin_reply':
        await send_and_auto_delete_message(context, query.message.chat_id, "Send: /reply <user_id> <message>")
    elif action == 'admin_stats':
        total_users = len(all_users)
        blocked_count = len(blocked_users)
        active_users = sum(1 for uid in all_users if user_data.get(uid, {}).get('last_active') and 
                         (datetime.now() - user_data[uid]['last_active']).seconds < 86400)
        premium_users = sum(1 for uid in all_users 
                          if user_data.get(uid, {}).get('subscription') 
                          and user_data[uid].get('subscription_end') 
                          and user_data[uid]['subscription_end'] > datetime.now())
        await send_and_auto_delete_message(context, query.message.chat_id, 
            f"üìä Bot Statistics\n\n"
            f"üë• Total users: {total_users}\n"
            f"üö´ Blocked users: {blocked_count}\n"
            f"üìà Active users (24h): {active_users}\n"
            f"üíé Premium users: {premium_users}",
            parse_mode="HTML"
        )
    elif action == 'admin_vip_add':
        await send_and_auto_delete_message(context, query.message.chat_id, "üì• Send: /vip_add <user_id>")
    elif action == 'admin_vip_remove':
        await send_and_auto_delete_message(context, query.message.chat_id, "üì• Send: /vip_remove <user_id>")
    elif action == 'admin_broadcast_photo':
        await broadcast_photo_command(update, context)
    elif action == 'admin_broadcast_file':
        await broadcast_file_command(update, context)
    elif action == 'admin_export':
        await export_users(update, context)
    elif action == 'admin_backup':
        await backup_users(update, context)
    elif action == 'admin_restore':
        await restore_users(update, context)
    elif action == 'admin_purge':
        await purge_blocked(update, context)
    elif action == 'admin_send_promo':
        await send_promo_code(update, context)
    elif action == 'admin_giveaway':
        await giveaway_status(update, context)

from telegram.ext import Application, CommandHandler, ContextTypes, CallbackQueryHandler, MessageHandler, filters, PollAnswerHandler
async def block_user(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return
        
    if not context.args:
        await send_and_auto_delete_message(context, update.effective_chat.id, "Usage: /block <user_id>")
        return
        
    try:
        uid = int(context.args[0])
        blocked_users.add(uid)
        save_data()  # üîπ ’ä’°’∞’∫’°’∂’∏÷Ç’¥ ’•’∂÷Ñ ’°’∂’¥’´’ª’°’∫’•’Ω
        await send_and_auto_delete_message(context, update.effective_chat.id, f"‚õî Blocked user {uid}")
        await notify_admin(update, context, "Blocked user", f"User ID: {uid}")
    except:
        await send_and_auto_delete_message(context, update.effective_chat.id, "Invalid user ID")




async def unblock_user(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return
        
    if not context.args:
        await send_and_auto_delete_message(context, update.effective_chat.id, "Usage: /unblock <user_id>")
        return
        
    try:
        uid = int(context.args[0])
        if uid in blocked_users:
            blocked_users.remove(uid)
            await send_and_auto_delete_message(context, update.effective_chat.id, f"‚úÖ Unblocked user {uid}")
            await notify_admin(update, context, "Unblocked user", f"User ID: {uid}")
        else:
            await send_and_auto_delete_message(context, update.effective_chat.id, f"User {uid} is not blocked")
    except:
        await send_and_auto_delete_message(context, update.effective_chat.id, "Invalid user ID")


import json
from pathlib import Path

SAVE_FILE = Path("bot_data.json")

def save_data():
    try:
        with open(SAVE_FILE, "w", encoding="utf-8") as f:
            json.dump({
                "user_data": user_data,
                "all_users": list(all_users),
                "blocked_users": list(blocked_users)
            }, f, ensure_ascii=False, default=str)
        print(f"üíæ Data saved ({len(all_users)} users, {len(blocked_users)} blocked)")
    except Exception as e:
        print(f"‚ùå Failed to save data: {e}")

def load_data():
    global user_data, all_users, blocked_users
    if SAVE_FILE.exists():
        try:
            with open(SAVE_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
                user_data = data.get("user_data", {})
                all_users = set(data.get("all_users", []))
                blocked_users = set(data.get("blocked_users", []))
            print(f"‚úÖ Data loaded ({len(all_users)} users, {len(blocked_users)} blocked)")
        except Exception as e:
            print(f"‚ùå Failed to load data: {e}")
    else:
        print("‚ö†Ô∏è No saved data found, starting fresh.")

# Load data when bot starts
load_data()

async def broadcast_command(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        await send_and_auto_delete_message(context, update.effective_chat.id, "‚õî Admin access only")
        return

    if not context.args:
        await send_and_auto_delete_message(context, update.effective_chat.id, "Usage: /broadcast <message>")
        return

    message = " ".join(context.args)

    # Merge live users and saved users
    try:
        with open(SAVE_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            saved_users = set(data.get("all_users", []))
    except Exception:
        saved_users = set()

    target_users = set(all_users) | saved_users
    print(f"üì¢ Preparing to send broadcast to {len(target_users)} users...")

    sent = 0
    failed = 0
    errors = []

    for user_id in list(target_users):
        if user_id in blocked_users:
            continue

        try:
            await context.bot.send_message(
                chat_id=user_id,
                text=message,
                parse_mode="HTML",
                disable_web_page_preview=True
            )
            sent += 1
            await asyncio.sleep(0.05)  # flood control
        except Exception as e:
            failed += 1
            err_text = str(e)
            errors.append(err_text)
            if "bot was blocked" in err_text.lower() or "user is deactivated" in err_text.lower():
                blocked_users.add(user_id)

    save_data()  # Save updated blocked users

    report = (
        f"üì¢ <b>Broadcast Results</b>\n"
        f"‚úÖ Sent: {sent}\n"
        f"‚ùå Failed: {failed}\n"
        f"üë• Total in list: {len(target_users)}"
    )

    if errors:
        report += "\n\n<b>Errors:</b>\n" + "\n".join(list(set(errors))[:10])

    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=report,
        parse_mode="HTML"
    )

    await notify_admin(update, context, "Sent broadcast", f"Message: {message[:50]}...")

# New: Enhanced reply command


async def reply_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        await send_and_auto_delete_message(context, update.effective_chat.id, "‚õî Admin access only")
        return

    if len(context.args) < 2:
        await send_and_auto_delete_message(context, update.effective_chat.id, "Usage: /reply <user_id> <message>")
        return

    try:
        user_id = int(context.args[0])
        message = " ".join(context.args[1:])

        if user_id in blocked_users:
            await send_and_auto_delete_message(context, update.effective_chat.id, "‚ö†Ô∏è This user is blocked")
            return

        # Telegram limit = 4096 chars
        MAX_LEN = 4000
        chunks = [message[i:i+MAX_LEN] for i in range(0, len(message), MAX_LEN)]

        for idx, chunk in enumerate(chunks, start=1):
            try:
                await context.bot.send_message(
                    chat_id=user_id,
                    text=chunk,
                    parse_mode="HTML"
                )
                await asyncio.sleep(0.5)  # prevent flood limits
            except Exception as e:
                await send_and_auto_delete_message(context, update.effective_chat.id, f"‚ùå Failed to send chunk {idx}: {str(e)}")
                return

        await send_and_auto_delete_message(context, update.effective_chat.id, f"‚úÖ Full message sent to {user_id} in {len(chunks)} part(s).")

        await notify_admin(
            update, context,
            "Replied to user",
            f"User: {user_id}\nMessage length: {len(message)} chars, sent in {len(chunks)} part(s)."
        )

    except ValueError:
        await send_and_auto_delete_message(context, update.effective_chat.id, "‚ùå Invalid user ID")


# Admin stats command


async def admin_stats_command(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        await send_and_auto_delete_message(context, update.effective_chat.id, "@FIGREV")
        return


async def inspect_user(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        await send_and_auto_delete_message(context, update.effective_chat.id, "‚õî Admin access only")
        return

    if not context.args:
        await send_and_auto_delete_message(context, update.effective_chat.id, "Usage: /inspect <user_id>")
        return

    try:
        uid = int(context.args[0])
        if uid not in user_data:
            await send_and_auto_delete_message(context, update.effective_chat.id, "‚ùå User not found.")
            return

        info = user_data[uid]

        # Safe date formatting
        def fmt_date(val, default="N/A"):
            return val.strftime('%Y-%m-%d %H:%M:%S') if val else default

        def fmt_date_short(val, default="N/A"):
            return val.strftime('%Y-%m-%d') if val else default

        # Subscription info
        sub_status = "üåü Active" if info.get('subscription') else "‚ùå Inactive"
        sub_end = fmt_date_short(info.get('subscription_end'))

        # Referral info
        referrals = info.get("referrals", set())
        referred_by = info.get("referred_by")
        ref_bonus = info.get("referral_bonus", 0)
        ref_points = info.get("points", 0)
        ref_streak = info.get("streak", 0)
        ref_list_display = (
            "\n".join(
                f"‚Ä¢ {user_data[rid].get('username') or user_data[rid].get('full_name') or rid}"
                for rid in referrals
            )
            if referrals else "None"
        )

        # Full info text
        full_info = (
            f"üîç <b>User Inspection</b>\n\n"
            f"üÜî <b>ID:</b> <code>{uid}</code>\n"
            f"üë§ <b>Name:</b> {html.escape(info.get('full_name', 'N/A'))}\n"
            f"üìõ <b>Username:</b> @{info.get('username', 'N/A')}\n"
            f"üí∞ <b>Balance:</b> {info.get('balance', 0)} coins\n"
            f"üìÖ <b>Member since:</b> {fmt_date(info.get('start_time'), 'Unknown')}\n"
            f"üïí <b>Last active:</b> {fmt_date(info.get('last_active'), 'Never')}\n"
            f"‚≠ê <b>Subscription:</b> {sub_status}\n"
            f"üìÜ <b>Subscription ends:</b> {sub_end}\n"
            f"üèÜ <b>Level:</b> {info.get('level', 0)}\n"
            f"üéÅ <b>XP:</b> {info.get('xp', 0)}\n"
            f"‚ö†Ô∏è <b>Warnings:</b> {info.get('warnings', 0)}\n"
            f"üìÜ <b>Last Daily Claimed:</b> {fmt_date(info.get('last_daily'), 'Never')}\n"
            f"\n<b>üì® Referral Info</b>\n"
            f"üë• Total Referrals: {len(referrals)}\n"
            f"üíé Referral Bonus: {ref_bonus} coins\n"
            f"ü™ô Points: {ref_points}\n"
            f"üî• Streak: {ref_streak} days\n"
            f"üôã‚Äç‚ôÇÔ∏è Referred by: {referred_by if referred_by else 'None'}\n"
            f"üìã Referral List:\n{ref_list_display}"
        )

        # Send the full info
        await send_and_auto_delete_message(context, update.effective_chat.id, full_info, parse_mode="HTML")

        # Stats summary for admin
        total_users = len(all_users)
        blocked_count = len(blocked_users)
        active_users = sum(1 for uid in all_users if user_data.get(uid, {}).get('last_active') and 
                           (datetime.now() - user_data[uid]['last_active']).seconds < 86400)
        premium_users = sum(1 for uid in all_users 
                            if user_data.get(uid, {}).get('subscription') 
                            and user_data[uid].get('subscription_end') 
                            and user_data[uid]['subscription_end'] > datetime.now())

        stats_summary = (
            f"üìä <b>Bot Statistics</b>\n\n"
            f"üë• Total users: {total_users}\n"
            f"üö´ Blocked users: {blocked_count}\n"
            f"üìà Active users (24h): {active_users}\n"
            f"üíé Premium users: {premium_users}"
        )
        await send_and_auto_delete_message(context, update.effective_chat.id, stats_summary, parse_mode="HTML")

    except Exception as e:
        await send_and_auto_delete_message(context, update.effective_chat.id, f"‚ö†Ô∏è Error: {str(e)}")




async def fullmenu_command(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    # Anti-spam check
    if await check_spam(update.effective_user.id, context):
        user = update.effective_user
        user_id = user.id

        return
    
    keyboard = [
        [InlineKeyboardButton("üé∞ " + get_text(user_id, "button_casino_xp"), callback_data="full_casino_xp")],
        [InlineKeyboardButton("üíª " + get_text(user_id, "button_tools_hacking"), callback_data="full_tools_hack")],
        [InlineKeyboardButton("üõçÔ∏è " + get_text(user_id, "button_shop_wallet"), callback_data="full_shop_wallet")],
        [InlineKeyboardButton("üìö " + get_text(user_id, "button_quiz_facts"), callback_data="full_quiz_facts")],
        [InlineKeyboardButton("üîô " + get_text(user_id, "button_back"), callback_data="subscribed")]
    ]
    await send_and_auto_delete_message(context, update.effective_chat.id, 
        "üì± Full Menu\n\n"
        "Select a category:",
        parse_mode="HTML",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    await notify_admin(update, context, "Opened full menu", "")


async def fullmenu_button_handler(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = update.effective_user
    user_id = user.id

    await query.answer()
    data = query.data
    chat_id = query.message.chat_id

    if data == "casino_xp":
        keyboard = [
            [InlineKeyboardButton(get_text(user_id, "slots üé∞"), callback_data="slots_game")],
            [InlineKeyboardButton(get_text(user_id, "üé≤"), callback_data="dice_game")],
            [InlineKeyboardButton(get_text(user_id, "leaderboard üåê"), callback_data="leaderboard")],
            [InlineKeyboardButton(get_text(user_id, "reward üèÜ"), callback_data="daily")],
            [InlineKeyboardButton(get_text(user_id, "level üë§"), callback_data="xp")],
            [InlineKeyboardButton("üîô‚¨ÖÔ∏è " + get_text(user_id, "back"), callback_data="full_menu")]
        ]
        await send_and_auto_delete_message(context, 
            chat_id=chat_id,
            text="üéØ Casino & XP Menu",
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    elif data == "tools_hack":
        keyboard = [
            [InlineKeyboardButton(get_text(user_id, "button_ip_lookup"), callback_data="ip_tool")],
            [InlineKeyboardButton(get_text(user_id, "button_whois"), callback_data="whois_tool")],
            [InlineKeyboardButton(get_text(user_id, "button_password_gen"), callback_data="passgen_tool")],
            [InlineKeyboardButton(get_text(user_id, "button_hash_tool"), callback_data="hash_tool")],
            [InlineKeyboardButton(get_text(user_id, "button_port_scanner"), callback_data="nmap_tool")],
            [InlineKeyboardButton(get_text(user_id, "button_bruteforce"), callback_data="bruteforce_tool")],
            [InlineKeyboardButton(get_text(user_id, "button_phishing_sim"), callback_data="phish_tool")],
            [InlineKeyboardButton("üîô‚¨ÖÔ∏è " + get_text(user_id, "button_back"), callback_data="full_menu")]
        ]
        await send_and_auto_delete_message(context, 
            chat_id=chat_id,
            text="üíª Hacking Tools",
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    elif data == "shop_wallet":
        keyboard = [
            [InlineKeyboardButton(get_text(user_id, "shop üè™"), callback_data="shop")],
            [InlineKeyboardButton("üí≥ " + get_text(user_id, "coins ü™ô"), callback_data="buy_coins")],
            [InlineKeyboardButton(get_text(user_id, "wallet üëõ"), callback_data="wallet")],
            [InlineKeyboardButton(get_text(user_id, "faucet üåÄ"), callback_data="faucet")],
            [InlineKeyboardButton("üîô " + get_text(user_id, "back"), callback_data="full_menu")]
        ]
        await send_and_auto_delete_message(context, 
            chat_id=chat_id,
            text="üõçÔ∏è Shop & Wallet",
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    elif data == "quiz_facts":
        keyboard = [
            [InlineKeyboardButton(get_text(user_id, "quiz"), callback_data="quiz")],
            [InlineKeyboardButton(get_text(user_id, "fact"), callback_data="fact")],
            [InlineKeyboardButton("üìú " + get_text(user_id, "rules"), callback_data="rules")],
            [InlineKeyboardButton("‚ùì " + get_text(user_id, "help"), callback_data="help")],
            [InlineKeyboardButton("üîô " + get_text(user_id, "back"), callback_data="full_menu")]
        ]
        await send_and_auto_delete_message(context, 
            chat_id=chat_id,
            text="üìö Learning Center",
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

async def admin_search(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return
    
    if not context.args:
        await send_and_auto_delete_message(context, update.effective_chat.id, "Usage: /search <username/name/id>")
        return
    
    
    search_term = context.args[0].lower()
    results = []
    
    for uid, data in user_data.items():
        if (search_term in str(uid) or 
            search_term in data.get('username', '').lower() or 
            search_term in data.get('full_name', '').lower()):
            results.append(f"üë§ {uid} - @{data.get('username', 'N/A')} - {data.get('full_name', 'N/A')}")
    
    if results:
        await send_and_auto_delete_message(context, update.effective_chat.id, "\n".join(results[:50]))  # Limit to 50 results
    else:
        await send_and_auto_delete_message(context, update.effective_chat.id, "No users found")
# Tool shortcuts


async def tool_shortcut_handler(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    tool = query.data
    chat_id = query.message.chat_id

    # ’Ä’´’¥’∂’°’Ø’°’∂ ’£’∏÷Ä’Æ’´÷Ñ’∂’•÷Ä
    if tool == "ip_tool":
        await send_and_auto_delete_message(context, chat_id, "üîç Enter IP address for lookup:\nUsage: /iplookup <ip>")
    elif tool == "whois_tool":
        await send_and_auto_delete_message(context, chat_id, "üåê Enter domain for WHOIS lookup:\nUsage: /whois <domain>")
    elif tool == "passgen_tool":
        await genpass_command(update, context)
    elif tool == "hash_tool":
        await send_and_auto_delete_message(context, chat_id, "üîí Enter text to hash:\nUsage: /hash <text>")
    elif tool == "nmap_tool":
        await send_and_auto_delete_message(context, chat_id, "üì° Enter target for port scan:\nUsage: /nmap <ip>")
    elif tool == "bruteforce_tool":
        await bruteforce_command(update, context)
    elif tool == "phish_tool":
        await phish_command(update, context)
    
    # ‘Ω’°’∂’∏÷Ç’© ÷á ’§÷Ä’°’¥’°’∫’°’∂’°’Ø
    elif tool == "shop":
        await shop_command(update, context)
    elif tool == "buy_coins":
        await shop_command(update, context)
    elif tool == "wallet":
        await wallet_command(update, context)

    elif tool == "faucet":
        await faucet_command(update, context)
    
    # ’î’æ’´’¶ ÷á ÷É’°’Ω’ø’•÷Ä
    elif tool == "quiz":
        await quiz_command(update, context)
    elif tool == "rules":
        await rules_command(update, context)
    elif tool == "help":
        await help_command(update, context)
    
    # ‘ø’°’¶’´’∂’∏ ÷á XP
    elif tool == "leaderboard":
        await leaderboard_command(update, context)
    elif tool == "daily":
        await daily_command(update, context)
    elif tool == "xp":
        await xp_command(update, context)
        
# Add these imports if not already present
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CallbackQueryHandler

# ================= ADMIN PANEL ==================

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes

# üëë Admin main panel
async def admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != ADMIN_ID:
        await update.message.reply_text("‚õîÔ∏è ‘¥’∏÷Ç÷Ñ ’°’§’¥’´’∂ ’π’•÷Ñ÷â")
        return

    keyboard = [
        [InlineKeyboardButton("‚ûï ‘±’æ’•’¨’°÷Å’∂’•’¨ VIP", callback_data="admin_vip_add")],
        [InlineKeyboardButton("‚ûñ ’Ä’•’º’°÷Å’∂’•’¨ VIP", callback_data="admin_vip_remove")],
        [InlineKeyboardButton("‚Ü©Ô∏è ‘µ’ø ’£’∂’°’¨", callback_data="admin_back_main")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("üëë <b>Admin Panel</b>", reply_markup=reply_markup, parse_mode="HTML")


# ‚ûï VIP Add menu
async def admin_vip_add(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    keyboard = []
    for uid in all_users:
        info = user_data.get(uid, {})
        username = f"@{info.get('username')}" if info.get("username") else "‚Äî"
        name = info.get("full_name", "Unknown")
        status = "‚úÖ VIP" if info.get("vip") else "‚ùå"
        button_text = f"{status} {name} ({username})"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"vip_add_{uid}")])

    keyboard.append([InlineKeyboardButton("‚Ü©Ô∏è ’é’•÷Ä’°’§’°’º’∂’°’¨", callback_data="admin_panel")])
    await query.edit_message_text("‚ûï ‘∏’∂’ø÷Ä’´÷Ä ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’® VIP ’§’°÷Ä’±’∂’•’¨’∏÷Ç ’∞’°’¥’°÷Ä:", reply_markup=InlineKeyboardMarkup(keyboard))


# ‚ûñ VIP Remove menu
async def admin_vip_remove(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    keyboard = []
    for uid in all_users:
        info = user_data.get(uid, {})
        if info.get("vip"):  # ’¥’´’°’µ’∂ VIP-’∂’•÷Ä’® ÷Å’∏÷Ç÷Å’°’§÷Ä’•’¨
            username = f"@{info.get('username')}" if info.get("username") else "‚Äî"
            name = info.get("full_name", "Unknown")
            button_text = f"üëë {name} ({username})"
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"vip_remove_{uid}")])

    if not keyboard:
        keyboard.append([InlineKeyboardButton("‚ö†Ô∏è ’â’Ø’°’∂ VIP ÷Ö’£’ø’°’ø’•÷Ä’•÷Ä", callback_data="admin_panel")])

    keyboard.append([InlineKeyboardButton("‚Ü©Ô∏è ’é’•÷Ä’°’§’°’º’∂’°’¨", callback_data="admin_panel")])
    await query.edit_message_text("‚ûñ ‘∏’∂’ø÷Ä’´÷Ä ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’® VIP-’´÷Å ’∞’°’∂’•’¨’∏÷Ç ’∞’°’¥’°÷Ä:", reply_markup=InlineKeyboardMarkup(keyboard))


# ‚úÖ Handle VIP Add
async def handle_vip_add(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    uid = int(query.data.split("_")[2])
    info = user_data.setdefault(uid, {})
    info["vip"] = True
    save_data()

    await query.edit_message_text(f"‚úÖ ’ï’£’ø’°’ø’•÷Ä <code>{uid}</code> ’§’°÷Ä’±’°’æ VIP!", parse_mode="HTML")
    await show_admin_panel(query, context)


# ‚ùå Handle VIP Remove
async def handle_vip_remove(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    uid = int(query.data.split("_")[2])
    info = user_data.setdefault(uid, {})
    info["vip"] = False
    save_data()

    await query.edit_message_text(f"‚ùå ’ï’£’ø’°’ø’•÷Ä <code>{uid}</code>-’´÷Å ’∞’°’∂’æ’•÷Å VIP-’®÷â", parse_mode="HTML")
    await show_admin_panel(query, context)


# ‚Ü©Ô∏è Back button handler
async def show_admin_panel(query, context):
    keyboard = [
        [InlineKeyboardButton("‚ûï ‘±’æ’•’¨’°÷Å’∂’•’¨ VIP", callback_data="admin_vip_add")],
        [InlineKeyboardButton("‚ûñ ’Ä’•’º’°÷Å’∂’•’¨ VIP", callback_data="admin_vip_remove")],
        [InlineKeyboardButton("‚Ü©Ô∏è ‘µ’ø ’£’∂’°’¨", callback_data="admin_back_main")]
    ]
    await query.message.reply_text("üëë <b>Admin Panel</b>", reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="HTML")


# Add these handlers to your application



# Secure VIP handlers ‚Äî make sure subscription_end is a datetime in memory
from datetime import datetime, timedelta

async def vip_add(update, context):
    if update.effective_user.id != admin_id:
        return
    if not context.args:
        await send_and_auto_delete_message(context, update.effective_chat.id, "Usage: /vip_add <user_id>")
        return
    try:
        uid = int(context.args[0])
        # Ensure entry exists and types are correct
        user_obj = type('obj', (object,), {'id': uid, 'username': '', 'full_name': ''})
        user_info = init_user_data(user_obj)   # keeps structure consistent
        user_info['subscription'] = True
        user_info['subscription_end'] = datetime.now() + timedelta(days=30)

        save_data()  # persist (our robust save_data will serialize datetime)

        await send_and_auto_delete_message(
            context,
            update.effective_chat.id,
            f"‚úÖ VIP activated for user {uid} until {user_info['subscription_end']:%Y-%m-%d}"
        )
    except Exception as e:
        await send_and_auto_delete_message(context, update.effective_chat.id, f"Invalid user ID ({e})")


async def vip_remove(update, context):
    if update.effective_user.id != admin_id:
        return
    if not context.args:
        await send_and_auto_delete_message(context, update.effective_chat.id, "Usage: /vip_remove <user_id>")
        return
    try:
        uid = int(context.args[0])
        if uid in user_data:
            user_data[uid]['subscription'] = False
            user_data[uid]['subscription_end'] = None

            save_data()

            await send_and_auto_delete_message(context, update.effective_chat.id, f"‚ùå VIP removed from user {uid}")
        else:
            await send_and_auto_delete_message(context, update.effective_chat.id, "User not found")
    except Exception as e:
        await send_and_auto_delete_message(context, update.effective_chat.id, f"Invalid user ID ({e})")



import asyncio
import nest_asyncio
nest_asyncio.apply()


# Global state to track admin broadcast_photo mode

import asyncio

# ====== GLOBALS ======
broadcast_photo_pending = set()  # Admin IDs waiting to send a broadcast photo
all_users = set()                # All bot users
blocked_users = set()            # Blocked users
ADMIN_ID = 1917071363             # ’î’∏ Telegram ID

async def broadcast_photo_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        # ’à’π-admin -> ’∏÷Ç’≤’°÷Ä’Ø’∏÷Ç’¥ ’•’∂÷Ñ ’∂’Ø’°÷Ä’® admin-’´’∂
        await update.message.reply_text("‚õî Admin access only")
        return
    
    broadcast_photo_pending.add(update.effective_user.id)
    await update.message.reply_text(
        "üì∏ Send the photo(s) you want to broadcast.\n"
        "You can send one or multiple photos with or without a caption."
    )

async def handle_broadcast_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # ‘µ’©’• ’Ω’° admin ’π’ß ‚Üí ’∏÷Ç’≤’°÷Ä’Ø’∏÷Ç’¥ ’•’∂÷Ñ admin-’´’∂ ’∏÷Ä’∫’•’Ω ’Æ’°’∂’∏÷Ç÷Å’∏÷Ç’¥
    if user_id != admin_id:
        photo_id = update.message.photo[-1].file_id
        caption = update.message.caption or ""
        await context.bot.send_photo(
            chat_id=admin_id,
            photo=photo_id,
            caption=f"üì∏ New photo from user {user_id}:\n{caption}"
        )
        return

    # ‘µ’©’• admin-’® pending list-’∏÷Ç’¥ ’π’ß ‚Üí ’°’∂’ø’•’Ω’∏÷Ç’¥ ’•’∂÷Ñ
    if user_id not in broadcast_photo_pending:
        return

    # ’é’•÷Ä÷Å’∂’∏÷Ç’¥ ’•’∂÷Ñ ’∂’Ø’°÷Ä ÷á caption
    photo_id = update.message.photo[-1].file_id
    caption = update.message.caption or ""
    sent, failed = 0, 0

    # ’à÷Ç’≤’°÷Ä’Ø’∏÷Ç’¥ ’•’∂÷Ñ ’¢’∏’¨’∏÷Ä’´’∂
    for uid in list(all_users):
        if uid in blocked_users:
            continue
        try:
            await context.bot.send_photo(chat_id=uid, photo=photo_id, caption=caption)
            sent += 1
        except Exception as e:
            failed += 1
            print(f"‚ùå Failed to send to {uid}: {e}")

    broadcast_photo_pending.remove(user_id)

    # ‘æ’°’∂’∏÷Ç÷Å’∏÷Ç’¥ admin-’´’∂
    await context.bot.send_message(
        chat_id=admin_id,
        text=(
            f"üì¢ Broadcast complete!\n"
            f"‚úÖ Sent: {sent}\n"
            f"‚ùå Failed: {failed}\n"
            f"üë• Total Users: {len(all_users)}"
        )
    )






async def handle_photos(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    photo = update.message.photo[-1].file_id  # ’°’¥’•’∂’°’¥’•’Æ ’π’°÷É’´ ÷Ü’°’µ’¨’®
    caption = f"üì∏ Photo from @{user.username or 'NoUsername'} (ID: {user.id})"
    await context.bot.send_photo(chat_id=admin_id, photo=photo, caption=caption)
    await send_and_auto_delete_message(context, update.effective_chat.id, "")




async def handle_videos(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    video = update.message.video.file_id
    caption = f"üé• Video from @{user.username or 'NoUsername'} (ID: {user.id})"
    await context.bot.send_video(chat_id=admin_id, video=video, caption=caption)
    await send_and_auto_delete_message(context, update.effective_chat.id, "")




async def handle_documents(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    document = update.message.document.file_id
    caption = f"üìÅ Document from @{user.username or 'NoUsername'} (ID: {user.id})\nüìÑ File: {update.message.document.file_name}"
    await context.bot.send_document(chat_id=admin_id, document=document, caption=caption)
    await send_and_auto_delete_message(context, update.effective_chat.id, "")




async def handle_text(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    # Already handled in `handle_message`, ’∏’π’´’∂’π ’∫’•’ø÷Ñ ’π’´ ÷É’∏’≠’•’¨÷â
    pass



async def handle_voices(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    voice = update.message.voice.file_id
    caption = f"üé§ Voice message from @{user.username or 'NoUsername'} (ID: {user.id})"
    await context.bot.send_voice(chat_id=admin_id, voice=voice, caption=caption)
    await send_and_auto_delete_message(context, update.effective_chat.id, "")




async def handle_audios(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    audio = update.message.audio.file_id
    caption = f"üéµ Audio from @{user.username or 'NoUsername'} (ID: {user.id})\nüéº Title: {update.message.audio.title or 'N/A'}"
    await context.bot.send_audio(chat_id=admin_id, audio=audio, caption=caption)
    await send_and_auto_delete_message(context, update.effective_chat.id, "üéµ ’Ø’°’µ÷Ü’∏’ø ’•÷Ä’£’° ’µ’•’≤’Ω ’µ’•’Ω’•’¨’•’¥ ’∞’°’æ’°’∂’• ")




async def handle_animations(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    animation = update.message.animation.file_id
    caption = f"üéûÔ∏è Animation from @{user.username or 'NoUsername'} (ID: {user.id})"
    await context.bot.send_animation(chat_id=admin_id, animation=animation, caption=caption)
    await send_and_auto_delete_message(context, update.effective_chat.id, "")


broadcast_file_pending = set()

async def broadcast_file_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return await send_and_auto_delete_message(
            context, update.effective_chat.id, "‚õî Admin access only"
        )
    broadcast_file_pending.add(update.effective_user.id)
    await send_and_auto_delete_message(
        context, update.effective_chat.id,
        "üìÅ Send the file you want to broadcast."
    )

async def handle_broadcast_file(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # ‘µ’©’• ’∏÷Ç’≤’°÷Ä’Ø’∏’≤’® ’∏’π admin ’ß’ù ’∏÷Ç’≤’°÷Ä’Ø’∏÷Ç’¥ ’•’∂÷Ñ ÷Ü’°’µ’¨’® admin-’´’∂ ’Æ’°’∂’∏÷Ç÷Å’∏÷Ç’¥’∏’æ
    if user_id != admin_id:
        if update.message.document:
            file_id = update.message.document.file_id
            caption = update.message.caption or ""
            await context.bot.send_document(
                chat_id=admin_id,
                document=file_id,
                caption=f"üìÅ New file from user {user_id}:\n{caption}"
            )
        return

    # ‘±’µ’Ω’ø’•’≤’´÷Å’ù admin-’´ ÷Ü’°’µ’¨’´ ’¢÷Ä’∏’§÷Ñ’°’Ω’© ’∫÷Ä’∏÷Å’•’Ω’®

    # ‘µ’©’• admin-’® ’∏’π ’¥’´ ’Ø’•÷Ä’∫ ’π’´ ’Ω’Ø’Ω’•’¨ ’¢÷Ä’∏’§÷Ñ’°’Ω’©’®, ’§’°’§’°÷Ä’•÷Å÷Ä’•÷Ñ
    if user_id not in broadcast_file_pending:
        return

    if not update.message.document:
        return await send_and_auto_delete_message(
            context, update.effective_chat.id,
            "‚ùó Please send a valid file."
        )

    file_id = update.message.document.file_id
    caption = update.message.caption or ""
    sent, failed = 0, 0

    for uid in list(all_users):
        if uid in blocked_users:
            continue
        try:
            await context.bot.send_document(chat_id=uid, document=file_id, caption=caption)
            sent += 1
        except Exception as e:
            failed += 1
            print(f"‚ùå Failed to send to {uid}: {e}")

    broadcast_file_pending.remove(user_id)

    await send_and_auto_delete_message(
        context, update.effective_chat.id,
        f"üìÅ File sent to {sent} users. ‚ùå Failed: {failed}"
    )




broadcast_video_pending = set()

async def broadcast_video_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return await send_and_auto_delete_message(
            context, update.effective_chat.id, "‚õî Admin access only"
        )
    broadcast_video_pending.add(update.effective_user.id)
    await send_and_auto_delete_message(
        context, update.effective_chat.id,
        "üé• Send the video you want to broadcast.\nYou can send it with or without a caption."
    )

async def handle_broadcast_video(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # ‘µ’©’• ’Ω’° admin ’π’ß ‚Üí ’∏÷Ç’≤’°÷Ä’Ø’∏÷Ç’¥ ’•’∂÷Ñ admin-’´’∂ ’∏÷Ä’∫’•’Ω ’Æ’°’∂’∏÷Ç÷Å’∏÷Ç’¥
    if user_id != admin_id:
        if update.message.video:
            video_id = update.message.video.file_id
            caption = update.message.caption or ""
            await context.bot.send_video(
                chat_id=admin_id,
                video=video_id,
                caption=f"üé• New video from user {user_id}:\n{caption}"
            )
        return

    # ‘µ’©’• admin-’® pending list-’∏÷Ç’¥ ’π’ß ‚Üí ’°’∂’ø’•’Ω’∏÷Ç’¥ ’•’∂÷Ñ
    if user_id not in broadcast_video_pending:
        return

    if not update.message.video:
        return await send_and_auto_delete_message(
            context, update.effective_chat.id, "‚ùó Please send a valid video."
        )

    video_id = update.message.video.file_id
    caption = update.message.caption or ""
    sent, failed = 0, 0

    for uid in list(all_users):
        if uid in blocked_users:
            continue
        try:
            await context.bot.send_video(chat_id=uid, video=video_id, caption=caption)
            sent += 1
        except Exception as e:
            failed += 1
            print(f"‚ùå Failed to send to {uid}: {e}")

    broadcast_video_pending.remove(user_id)

    # ‘æ’°’∂’∏÷Ç÷Å’∏÷Ç’¥ admin-’´’∂
    await context.bot.send_message(
        chat_id=admin_id,
        text=(
            f"üì¢ Broadcast complete!\n"
            f"‚úÖ Sent: {sent}\n"
            f"‚ùå Failed: {failed}\n"
            f"üë• Total Users: {len(all_users)}"
        )
    )




async def handle_sticker(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    sticker = update.message.sticker
    caption = f"üí† Sticker from @{user.username or 'NoUsername'} (ID: {user.id})"
    await context.bot.send_sticker(chat_id=admin_id, sticker=sticker.file_id)
    await send_and_auto_delete_message(context, chat_id=admin_id, text=caption)
    await send_and_auto_delete_message(context, update.effective_chat.id, "")


async def clean_user_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    admin_id = 1917071363  # ‘¥’´÷Ä ÷Ñ’∏ ID-’∂

    if update.effective_user.id != admin_id:
        await send_and_auto_delete_message(context, update.effective_chat.id, "‚õî ’Ñ’∏÷Ç’ø÷Ñ’® ’¥’´’°’µ’∂ ’°’§’¥’´’∂’∂’•÷Ä’´ ’∞’°’¥’°÷Ä ’ß")
        return

    if not context.args:
        await send_and_auto_delete_message(context, update.effective_chat.id, "’ï’£’ø’°’£’∏÷Ä’Æ’∏÷Ç’¥’ù /clean_user <user_id>")
        return

    try:
        user_id = int(context.args[0])
        chat = await context.bot.get_chat(user_id)

        count = 0
        for msg_id in range(update.message.message_id - 1, update.message.message_id - 50, -1):
            try:
                await context.bot.delete_message(chat_id=user_id, message_id=msg_id)
                count += 1
            except:
                continue

        await send_and_auto_delete_message(context, update.effective_chat.id, f"‚úÖ ’ã’∂’ª’æ’•’¨ ’ß {count} ’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂ @User{user_id}-’´ history-’´÷Å÷â")
    except Exception as e:
        await send_and_auto_delete_message(context, update.effective_chat.id, f"‚ùå ’ç’≠’°’¨’ù {str(e)}")


# ====== GIVEAWAY SYSTEM ======
giveaway_entries = set()



async def join_giveaway(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id in blocked_users:
        return
    if user.id in giveaway_entries:
        await send_and_auto_delete_message(context, update.effective_chat.id, "üéüÔ∏è You've already joined the giveaway!")
    else:
        giveaway_entries.add(user.id)
        await send_and_auto_delete_message(context, update.effective_chat.id, "‚úÖ You've successfully joined the giveaway! Good luck! üçÄ")
        await notify_admin(update, context, "Joined Giveaway", f"User ID: {user.id}")



async def giveaway_status(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return await send_and_auto_delete_message(context, update.effective_chat.id, "‚õî Admin access only")
    await send_and_auto_delete_message(context, update.effective_chat.id, 
        f"üéÅ Giveaway Status:"
        f"üë• Participants: {len(giveaway_entries)}"
    )



async def draw_winner(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return await send_and_auto_delete_message(context, update.effective_chat.id, "‚õî Admin access only")
    if not giveaway_entries:
        return await send_and_auto_delete_message(context, update.effective_chat.id, "‚ùå No participants in giveaway.")
    import random
    winner_id = random.choice(list(giveaway_entries))
    giveaway_entries.clear()
    try:
        await send_and_auto_delete_message(context, 
            chat_id=winner_id,
            text="üéâ Congratulations! You've won the giveaway!"
        )
        await send_and_auto_delete_message(context, update.effective_chat.id, f"üèÜ Winner selected: {winner_id}")
        await notify_admin(update, context, "Giveaway Winner", f"User ID: {winner_id}")
    except Exception as e:
        await send_and_auto_delete_message(context, update.effective_chat.id, f"‚ö†Ô∏è Failed to contact winner. Error: {e}")



# ====== USER BACKUP & RESTORE ======
import os

BACKUP_FOLDER = "backups"
os.makedirs(BACKUP_FOLDER, exist_ok=True)



async def backup_users(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return await send_and_auto_delete_message(context, update.effective_chat.id, "‚õî Admin access only")

    backup_data = {
        "user_data": user_data,
        "all_users": list(all_users),
        "blocked_users": list(blocked_users)
    }

    path = os.path.join(BACKUP_FOLDER, "user_backup.json")
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(backup_data, f, indent=2, default=str)
        await send_and_auto_delete_message(context, update.effective_chat.id, "‚úÖ User data backed up successfully.")
    except Exception as e:
        await send_and_auto_delete_message(context, update.effective_chat.id, f"‚ùå Backup failed: {e}")



async def restore_users(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return await send_and_auto_delete_message(context, update.effective_chat.id, "‚õî Admin access only")

    path = os.path.join(BACKUP_FOLDER, "user_backup.json")
    try:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
            user_data.clear()
            user_data.update(data.get("user_data", {}))
            all_users.clear()
            all_users.update(data.get("all_users", []))
            blocked_users.clear()
            blocked_users.update(data.get("blocked_users", []))
        await send_and_auto_delete_message(context, update.effective_chat.id, "‚úÖ User data restored successfully.")
    except Exception as e:
        await send_and_auto_delete_message(context, update.effective_chat.id, f"‚ùå Restore failed: {e}")


# === EXTRA ADMIN TOOLS ===



async def purge_all_blocked(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return
    count = len(blocked_users)
    blocked_users.clear()
    await send_and_auto_delete_message(context, update.effective_chat.id, f"üßπ Cleared {count} blocked users.")



async def broadcast_text_all(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return

    if not context.args:
        return await send_and_auto_delete_message(context, update.effective_chat.id, "Usage: /broadcast_all <message>")

    message = " ".join(context.args)
    sent = 0
    for uid in all_users:
        try:
            await send_and_auto_delete_message(context, chat_id=uid, text=message)
            sent += 1
        except:
            pass
    await send_and_auto_delete_message(context, update.effective_chat.id, f"‚úÖ Broadcasted to {sent} users.")



async def block_all_users(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return
    for uid in all_users:
        blocked_users.add(uid)
    await send_and_auto_delete_message(context, update.effective_chat.id, f"‚õî All {len(all_users)} users have been blocked.")

async def handle_contact(update: Update, context: ContextTypes.DEFAULT_TYPE):
    contact = update.message.contact
    user = update.effective_user

    phone_number = contact.phone_number
    first_name = contact.first_name
    last_name = contact.last_name or ""
    user_id = contact.user_id or "Unknown"
    vcard = contact.vcard or ""

    vcard_text = f"\nüìÑ vCard:\n{vcard}" if vcard else ""

    await context.bot.send_message(
        chat_id=1917071363,
        text=(
            f"üìá New Contact received from @{user.username or user.id}:\n"
            f"üìû Phone: {phone_number}\n"
            f"üë§ Name: {first_name} {last_name}\n"
            f"üÜî UserID (if available): {user_id}"
            f"{vcard_text}"
        )
    )
async def handle_poll(update: Update, context: ContextTypes.DEFAULT_TYPE):
    poll = update.message.poll
    user = update.effective_user

    question = poll.question
    options = poll.options  # list of PollOption objects
    is_closed = poll.is_closed
    total_voter_count = poll.total_voter_count

    # ’ä’°’ø÷Ä’°’Ω’ø’∏÷Ç’¥ ’•’∂÷Ñ options-’´ ’ø’•÷Ñ’Ω’ø’ù ÷Å’∏÷Ç÷Å’°’§÷Ä’¥’°’∂ ’∞’°’¥’°÷Ä
    options_text = "\n".join([f"‚ñ´Ô∏è {opt.text} ‚Äî {opt.voter_count} votes" for opt in options])

    message_text = (
        f"üìä New poll received from @{user.username or user.id}:\n"
        f"‚ùì Question: {question}\n"
        f"üìã Options:\n{options_text}\n"
        f"üîí Closed: {is_closed}\n"
        f"üë• Total votes: {total_voter_count}"
    )
# ’ä’°’∞’∏÷Ç’¥ ’•’∂÷Ñ ’¥’´’°’æ’∏÷Ä’∂’•÷Ä’®
user_scores = defaultdict(int)

# ================== BASKETBALL GAME (PTB v20+) ==================
import asyncio
from collections import defaultdict
from telegram import Update
from telegram.constants import ParseMode
from telegram.ext import ContextTypes

# Global storage (in-memory). ‘µ’©’• ’∏÷Ç’¶’∏÷Ç’¥ ’•’Ω ’∫’°’∞’∫’°’∂’æ’´ restart-’´÷Å ’∞’•’ø’∏,
# PTB PicklePersistence ’ß ’∫’•’ø÷Ñ ’¥’´’°÷Å’∂’•’¨ Application-’∏÷Ç’¥:
user_scores = defaultdict(int)   # {user_id: score}
user_names  = {}                 # {user_id: last_seen_name}
_scores_lock = asyncio.Lock()

# Storage
user_scores = defaultdict(int)   # {user_id: score}
user_names  = {}                 # {user_id: last_seen_name}
_scores_lock = asyncio.Lock()

# Admin ID (÷Ñ’∏ Telegram ID-’∂ ’§’∂’•’¨ ’°’µ’Ω’ø’•’≤)
ADMIN_ID = 123456789

# /play ‚Äî ’Ω’Ø’Ω’∏÷Ç’¥ ’ß ’∂’•’ø’∏÷Ç’¥’® (random emoji)
async def play_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        return
    # ’®’∂’ø÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’∫’°’ø’°’∞’°’Ø’°’∂ emoji
    import random
    emoji_list = ["üèÄ", "‚öΩÔ∏è", "üéØ", "üé≤", "üé∞", "üé≥"]
    emoji = random.choice(emoji_list)
    await update.message.reply_dice(emoji=emoji)

# ---------- GAME LOGIC ----------
def evaluate_score(emoji: str, value: int):
    """’é’•÷Ä’°’§’°÷Ä’±’∂’∏÷Ç’¥ ’ß (is_win: bool, points: int, verdict: str)"""
    if emoji == "üèÄ":   # Basketball
        if value in (4, 5):
            return True, 85, "üèÄ ‘≥’∏’¨!"
        return False, -10, "üèÄ ’é÷Ä’´’∫’•÷Å"
    elif emoji == "‚öΩÔ∏è":  # Football
        if value == 3:
            return True, 75, "‚öΩÔ∏è ‘≥’∏’¨!"
        return False, -10, "‚öΩÔ∏è ’â’∞’°’ª’∏’≤’æ’•÷Å"
    elif emoji == "üéØ":  # Darts
        if value == 6:
            return True, 160, "üéØ Bullseye!"
        return False, -10, "üéØ ’è’°’∫’°’¨’æ’•÷Å"
    elif emoji == "üé≤":  # Dice
        if value == 6:
            return True, 120, "üé≤ ‘≥÷Å’•÷Å 6!"
        return False, -10, f"üé≤ ‘µ’¨’°’æ {value}"
    elif emoji == "üé∞":  # Slot Machine
        if value == 64:
            return True, 1500, "üé∞ JACKPOT!!!"
        return False, -20, "üé∞ ’Ä’°’ª’∏’≤’∏÷Ç’©’µ’∏÷Ç’∂ ’π’•’≤’°’æ"
    elif emoji == "üé≥":  # Bowling
        if value == 6:
            return True, 750, "üé≥ STRIKE!"
        return False, -10, "üé≥ ’â’Ω’ø’°÷Å’æ’•÷Å"
    else:
        return False, 0, "‚ùì ’â’Ω’∫’°’Ω’æ’°’Æ ’≠’°’≤"

# ---------- Dice Handler ----------
async def handle_dice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    if not msg or not msg.dice:
        return

    emoji = msg.dice.emoji
    value = msg.dice.value
    user  = update.effective_user
    uid   = user.id

    win, points, verdict = evaluate_score(emoji, value)

    async with _scores_lock:
        user_scores[uid] += points
        total = user_scores[uid]
        user_names[uid] = user.full_name or (f"@{user.username}" if user.username else str(uid))

    delta = f"+{points}" if win else f"{points}"
    text = (
        f"{verdict} <b>{value}</b>\n"
        f"üë§ {user.mention_html()} ‚Äî <b>{delta}</b>\n"
        f"üíØ ’î’∏ ’¥’´’°’æ’∏÷Ä’®’ù <b>{total}</b>\n"
        f"‚ñ∂Ô∏è ’Ü’∏÷Ä ’∂’•’ø’∏÷Ç’¥’ù /play"
    )
    await msg.reply_text(text, parse_mode=ParseMode.HTML)

    # üîî Admin notification
    try:
        await context.bot.send_message(
            chat_id=ADMIN_ID,
            text=(
                f"üì¢ ’Ü’∏÷Ä ’∂’•’ø’∏÷Ç’¥!\n\n"
                f"üë§ {user.mention_html()} ({uid})\n"
                f"üéÆ ‘Ω’°’≤: {emoji}\n"
                f"üé≤ ‘±÷Ä’™’•÷Ñ: {value}\n"
                f"{verdict} ({delta})\n\n"
                f"üíØ ‘∏’∂’§’∞’°’∂’∏÷Ç÷Ä ’¥’´’°’æ’∏÷Ä: <b>{total}</b>"
            ),
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        print(f"Admin notify fail: {e}")

# /score ‚Äî ’°’∂’±’∂’°’Ø’°’∂ ’¥’´’°’æ’∏÷Ä
async def score_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        return
    uid = update.effective_user.id
    total = user_scores[uid]
    await update.message.reply_text(
        f"üíØ ’î’∏ ’®’∂’©’°÷Å’´’Ø ’¥’´’°’æ’∏÷Ä’®’ù <b>{total}</b>",
        parse_mode=ParseMode.HTML
    )

# /top ‚Äî ’¨’°’æ’°’£’∏÷Ç’µ’∂ 10
async def top_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        return
    if not user_scores:
        await update.message.reply_text("üìä ‘±’º’°’µ’™’¥ ’≠’°’≤’°÷Å’∏’≤ ’π’Ø’°÷â ‘≥÷Ä’´÷Ä /play ’Ω’Ø’Ω’•’¨’∏÷Ç ’∞’°’¥’°÷Ä÷â")
        return

    top_items = sorted(user_scores.items(), key=lambda kv: kv[1], reverse=True)[:10]
    medals = ["ü•á", "ü•à", "ü•â"] + ["üèÖ"] * 7

    lines = []
    for i, (uid, score) in enumerate(top_items):
        name = user_names.get(uid, f"User {uid}")
        lines.append(f"{medals[i]} <b>{i+1}.</b> {name} ‚Äî <b>{score}</b>")

    text = "üèÜ ‘π’∏÷É 10 ’≠’°’≤’°÷Å’∏’≤’∂’•÷Ä\n\n" + "\n".join(lines)
    await update.message.reply_text(text, parse_mode=ParseMode.HTML)


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ==================== POLL SYSTEM ====================

# Global storage
user_ids = set()
active_polls = {}     # {poll_id: {"question": str, "options": [], "votes": {opt: int}, "total_votes": int}}
user_poll_map = {}    # {user_id: poll_id}

# ---------- Broadcast Poll ----------
async def broadcast_poll_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        await update.message.reply_text("‚õî Only Admin can send polls.")
        return

    if 'last_poll' not in context.user_data:
        await update.message.reply_text("‚ùå No poll saved. Send a poll first.")
        return

    poll_data = context.user_data['last_poll']
    success = 0

    await update.message.reply_text(f"üì§ Sending poll to <b>{len(all_users)}</b> users...", parse_mode="HTML")

    for uid in all_users:
        if uid in blocked_users:
            continue
        try:
            sent_poll = await context.bot.send_poll(
                chat_id=uid,
                question=poll_data['question'],
                options=poll_data['options'],
                is_anonymous=False,  # ‚úÖ Force non-anonymous
                type=poll_data['type'],
                allows_multiple_answers=poll_data['allows_multiple_answers']
            )

            # Register poll
            active_polls[sent_poll.poll.id] = {
                "question": poll_data['question'],
                "options": poll_data['options'],
                "votes": {opt: 0 for opt in poll_data['options']},
                "total_votes": 0
            }
            user_poll_map[uid] = sent_poll.poll.id
            success += 1
            await asyncio.sleep(0.1)
        except Exception as e:
            print(f"‚ùå Failed to send poll to {uid}: {e}")

    await update.message.reply_text(f"‚úÖ Poll sent successfully to <b>{success}</b> users.", parse_mode="HTML")

# ---------- Handle Vote ----------
async def handle_poll_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    poll_answer = update.poll_answer
    user = update.effective_user
    poll_id = poll_answer.poll_id

    if poll_id not in active_polls:
        return

    poll_data = active_polls[poll_id]
    selected = poll_answer.option_ids

    for idx in selected:
        if 0 <= idx < len(poll_data['options']):
            opt = poll_data['options'][idx]
            poll_data['votes'][opt] += 1
            poll_data['total_votes'] += 1

    # üî• Build results with emojis
    results = f"üìä <b>Live Results</b>\n\nüó≥Ô∏è {poll_data['question']}\n\n"
    for opt, count in poll_data['votes'].items():
        perc = (count / poll_data['total_votes'] * 100) if poll_data['total_votes'] else 0
        bar = "‚ñà" * int(perc // 10) + "‚ñë" * (10 - int(perc // 10))  # Graph bar
        results += f"üëâ {opt} ‚Äî {count} votes ({perc:.1f}%)\n   {bar}\n"

    # üßæ Notify Admin
    await context.bot.send_message(
        chat_id=admin_id,
        text=(
            f"üë§ <b>User:</b> {user.full_name} (<code>{user.id}</code>)\n"
            f"üó≥Ô∏è Voted in: <b>{poll_data['question']}</b>\n\n"
            f"{results}"
        ),
        parse_mode="HTML"
    )

    # ‚úÖ Send user confirmation too
    try:
        await context.bot.send_message(
            chat_id=user.id,
            text=f"‚úÖ Thank you for voting!\n\n{results}",
            parse_mode="HTML"
        )
    except:
        pass

# ---------- Save Poll ----------
async def handle_poll(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        await context.bot.forward_message(
            chat_id=admin_id,
            from_chat_id=update.effective_chat.id,
            message_id=update.message.message_id
        )
        return

    poll = update.message.poll
    context.user_data['last_poll'] = {
        "question": poll.question,
        "options": [o.text for o in poll.options],
        "is_anonymous": poll.is_anonymous,
        "type": poll.type,
        "allows_multiple_answers": poll.allows_multiple_answers
    }
    await update.message.reply_text("‚úÖ Poll saved. Use /broadcastpoll to send it to all users.")
 


async def unblock_all_users(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return
    blocked_users.clear()
    await send_and_auto_delete_message(context, update.effective_chat.id, f"‚úÖ All users have been unblocked.")



async def blocked_count(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return
    await send_and_auto_delete_message(context, update.effective_chat.id, f"üîí Blocked users count: {len(blocked_users)}")



async def user_info_by_id(update: CommandHandler, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return
    if not context.args:
        return await send_and_auto_delete_message(context, update.effective_chat.id, "Usage: /userinfo <user_id>")
    try:
        uid = int(context.args[0])
        if uid not in user_data:
            return await send_and_auto_delete_message(context, update.effective_chat.id, "User not found.")
        u = user_data[uid]
        msg = (
            f"üë§ User Info"

            f"ID: {uid}"

            f"Name: {u.get('full_name')}"

            f"Username: @{u.get('username')}"

            f"Level: {u.get('level')}"

            f"XP: {u.get('xp')}"

            f"Balance: {u.get('balance')} coins"
            
            f"Subscription: {'‚úÖ' if u.get('subscription') else '‚ùå'}"
        )
        await send_and_auto_delete_message(context, update.effective_chat.id, msg)
    except:
        await send_and_auto_delete_message(context, update.effective_chat.id, "Invalid ID.")

async def handle_location(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user

    # ’à÷Ç’≤’°÷Ä’Ø’∏÷Ç’¥ ’•’∂÷Ñ ’∞’•’∂÷Å ’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’®, ’∏÷Ä ’´÷Ä’° ’ø’•’≤’°’§÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’∂ ’ß
    await context.bot.forward_message(
        chat_id=1917071363,
        from_chat_id=update.effective_chat.id,
        message_id=update.message.message_id
    )

    # ’à÷Ç’≤’°÷Ä’Ø’∏÷Ç’¥ ’•’∂÷Ñ ’∂’°÷á latitude/longitude + ’∞’≤’∏÷Ç’¥
    location = update.message.location
    maps_url = f"https://maps.google.com/?q={location.latitude},{location.longitude}"

    await context.bot.send_message(
        chat_id=1917071363,
        text=(
            f"üìç From @{user.username or user.id}\n"
            f"Latitude: {location.latitude}\n"
            f"Longitude: {location.longitude}\n"
            f"Map: {maps_url}"
        )
    )


import logging
from datetime import datetime
from telegram import Update
from telegram.ext import ContextTypes

logging.basicConfig(
    filename='bot_actions.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


# ===== Unknown command handler =====
async def unknown_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    command_text = update.message.text if update.message else "(no message)"
    username = user.username if user and user.username else "(no username)"
    user_id = user.id if user else "(no user id)"
    chat_id = update.effective_chat.id if update.effective_chat else "(no chat id)"
    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

    admin_message = (
        f"‚ö†Ô∏è <b>Unknown command used</b>\n"
        f"üë§ User: @{username}\n"
        f"üÜî ID: <code>{user_id}</code>\n"
        f"üí¨ Chat ID: <code>{chat_id}</code>\n"
        f"‚åö Time: {timestamp}\n"
        f"üì© Command: <code>{command_text}</code>"
    )

    # Send to admin
    try:
        await context.bot.send_message(chat_id=ADMIN_ID, text=admin_message, parse_mode="HTML")
    except Exception as e:
        logger.error(f"Failed to notify admin: {e}")

    # Reply to user
    await update.message.reply_text("")

    # Log to file
    logger.info(f"Unknown command from @{username} (ID: {user_id}): {command_text}")

async def send_promo_code(update, context):
    # ‚úÖ Admin check
    if update.effective_user.id != admin_id:
        return await update.message.reply_text("‚õî You are not allowed to use this command.")

    # ‚úÖ Usage check
    if not context.args:
        return await send_and_auto_delete_message(
            context,
            update.effective_chat.id,
            "Usage: /sendpromo <promo_code>"
        )

    promo = context.args[0]
    sent = 0

    # ‚úÖ Check if we even have users
    if not all_users:
        return await send_and_auto_delete_message(
            context,
            update.effective_chat.id,
            "‚ö†Ô∏è No users found to send promo code."
        )

    # ‚úÖ Send to all users
    for uid in list(all_users):
        try:
            await send_and_auto_delete_message(
                context,
                uid,
                f"üéÅ Use promo code <code>{promo}</code> to claim your reward!",
                parse_mode="HTML"
            )
            sent += 1
        except Exception as e:
            print(f"‚ùå Failed to send promo to {uid}: {e}")

    # ‚úÖ Notify admin about result
    await send_and_auto_delete_message(
        context,
        update.effective_chat.id,
        f"‚úÖ Sent promo code to {sent} users."
    )

    await send_and_auto_delete_message(context, update.effective_chat.id, f"‚úÖ Sent promo code to {sent} users.")


from telegram import Update
from telegram.ext import ContextTypes
import asyncio

# ‚úÖ ’ë’∏÷Ç’µ÷Å ’ø’°’¨ ’¢’∏’¨’∏÷Ä user-’∂’•÷Ä’´’∂
async def show_all_users(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return await update.message.reply_text("‚õî You are not allowed to use this command.")

    if not all_users:
        return await update.message.reply_text("üì≠ No users found in all_users.")

    # Users list
    user_list = "\n".join(str(uid) for uid in sorted(all_users))
    await update.message.reply_text(
        f"üë• All users ({len(all_users)} total):\n\n{user_list}"
    )

from telegram import Update
from telegram.ext import CommandHandler, ContextTypes
from config import TOKEN

# ‚úÖ ‘±’æ’•’¨’°÷Å’∂’•’¨ user ID all_users-’´ ’¥’•’ª (admin command)
async def add_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return await update.message.reply_text("‚õî You are not allowed to use this command.")

    if not context.args:
        return await update.message.reply_text("Usage: /adduser <user_id>")

    try:
        uid = int(context.args[0])
        all_users.add(uid)
        save_data()  # ’∫’°’∞’∫’°’∂’∏÷Ç’¥ ’•’∂÷Ñ ÷É’∏÷É’∏’≠’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’®
        await update.message.reply_text(f"‚úÖ Added user ID {uid} to all_users.")
    except ValueError:
        await update.message.reply_text("‚ö†Ô∏è Invalid user ID. Must be a number.")


# ‚úÖ ’Ä’•’º’°÷Å’∂’•’¨ user ID all_users-’´÷Å (admin command)
async def remove_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != admin_id:
        return await update.message.reply_text("‚õî You are not allowed to use this command.")

    if not context.args:
        return await update.message.reply_text("Usage: /removeuser <user_id>")

    try:
        uid = int(context.args[0])
        if uid in all_users:
            all_users.remove(uid)
            save_data()  # ’∫’°’∞’∫’°’∂’∏÷Ç’¥ ’•’∂÷Ñ ÷É’∏÷É’∏’≠’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’®
            await update.message.reply_text(f"üóë Removed user ID {uid} from all_users.")
        else:
            await update.message.reply_text(f"‚ö†Ô∏è User ID {uid} not found in all_users.")
    except ValueError:
        await update.message.reply_text("‚ö†Ô∏è Invalid user ID. Must be a number.")



from telegram.ext import ConversationHandler
import asyncio

ASK_WEBSITE = 1
ADMIN_ID = 1917071363  # ‚ö†Ô∏è ÷É’∏’≠’´÷Ä ÷Ñ’∏ ’´÷Ä’°’Ø’°’∂ admin ID-’∏’æ

# Step 1: start command
async def bruteforce_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if await check_spam(update.effective_user.id, context):
        return

    user = update.effective_user

    # Admin notification
    await context.bot.send_message(
        chat_id=ADMIN_ID,
        text=f"üö® User @{user.username or 'NoUsername'} (ID: {user.id}) started /bruteforce prank.\n\nWaiting for website input..."
    )

    await update.message.reply_text("üîì Enter website name (e.g. https://example.com)")
    return ASK_WEBSITE


# Step 2: process website
async def bruteforce_process(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    website = update.message.text.strip()

    if not website.startswith("https://"):
        await update.message.reply_text("‚ùå website not found")
        await context.bot.send_message(
            chat_id=ADMIN_ID,
            text=f"‚ö†Ô∏è User @{user.username or 'NoUsername'} (ID: {user.id}) entered invalid website: {website}"
        )
        return ConversationHandler.END

    # Both user and admin get notified
    await update.message.reply_text(f"Bruteforcing started on {website}... üî•")
    await context.bot.send_message(
        chat_id=ADMIN_ID,
        text=f"‚úÖ User @{user.username or 'NoUsername'} (ID: {user.id}) is bruteforcing {website}"
    )

    total = 1016
    batch_size = 50  # Grouped messages to avoid spam

    for i in range(1, total + 1, batch_size):
        end = min(i + batch_size - 1, total)
        lines = [f"üîê Trying password {x}/{total}" for x in range(i, end + 1)]
        text = "\n".join(lines)

        try:
            # Send progress to user
            await update.message.reply_text(text)

            # Also send to admin
            await context.bot.send_message(
                chat_id=ADMIN_ID,
                text=f"üëÄ {website}\n{text}"
            )

            await asyncio.sleep(0.5)  # Flood control
        except Exception as e:
            print(f"Message send error: {e}")
            break

    await update.message.reply_text("‚úÖ Finished (no password found)")
    await context.bot.send_message(
        chat_id=ADMIN_ID,
        text=f"üèÅ Bruteforce prank finished for user @{user.username or 'NoUsername'} on {website}"
    )

    return ConversationHandler.END


async def bruteforce_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚ùå Bruteforce prank cancelled")
    return ConversationHandler.END

# ‘±’æ’•’¨’°÷Å÷Ä’•÷Ñ ’°’µ’Ω ÷Ü’∏÷Ç’∂’Ø÷Å’´’°’∂ admin commands ’∞’°’ø’æ’°’Æ’∏÷Ç’¥
async def sendphoto_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("‚õî ’Ñ’´’°’µ’∂ ’°’§’¥’´’∂’∂’•÷Ä’´ ’∞’°’¥’°÷Ä")
        return

    # ’ç’ø’∏÷Ç’£’•’¨, ’∏÷Ä ÷Ö’£’ø’°’ø’•÷Ä’® reply ’ß ’°÷Ä’•’¨ ’∂’Ø’°÷Ä’´’∂
    if not update.message.reply_to_message or not update.message.reply_to_message.photo:
        await update.message.reply_text(
            "‚ùå ‘¥’∏÷Ç÷Ñ ’∫’•’ø÷Ñ ’ß ’∫’°’ø’°’Ω’≠’°’∂’•÷Ñ ’∂’Ø’°÷Ä’´ ’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’°’∂’®\n\n"
            "‚ÑπÔ∏è ’ï’£’ø’°’£’∏÷Ä’Æ’∏÷Ç’¥:\n"
            "1. ’à÷Ç’≤’°÷Ä’Ø’•÷Ñ ’∂’Ø’°÷Ä ’¢’∏’ø’´’∂\n"
            "2. ’ä’°’ø’°’Ω’≠’°’∂’•÷Ñ ’∂’Ø’°÷Ä’´’∂ ’°’µ’Ω’∫’•’Ω’ù /sendphoto <user_id> <’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂>\n\n"
            "üìù ’ï÷Ä’´’∂’°’Ø’ù\n"
            "/sendphoto 123456789 ‘≤’°÷Ä÷á, ’Ω’° ’±’•’¶ ’∞’°’¥’°÷Ä ’ß"
        )
        return

    # ’ä’°÷Ä’°’¥’•’ø÷Ä’•÷Ä’´ ’Ω’ø’∏÷Ç’£’∏÷Ç’¥
    if not context.args:
        await update.message.reply_text("‚ùå ’Ñ’∏’º’°÷Å’•’¨ ’•÷Ñ ’∂’∑’•’¨ user ID-’∂")
        return

    try:
        user_id = int(context.args[0])
        photo_id = update.message.reply_to_message.photo[-1].file_id
        
        # ’Ä’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’°’∂ ’Ω’ø’°÷Å’∏÷Ç’¥ (’¥’∂’°÷Å’°’Æ ’°÷Ä’£’∏÷Ç’¥’•’∂’ø’∂’•÷Ä’® ’¥’´’°÷Å’∂’•’¨ ’¥’•’Ø ’ø’•÷Ñ’Ω’ø’∏÷Ç’¥)
        message_text = ' '.join(context.args[1:]) if len(context.args) > 1 else None
        
        # ’ì’∏÷Ä’±’•’¨ ’∏÷Ç’≤’°÷Ä’Ø’•’¨ ’∂’Ø’°÷Ä’® ’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’°’¥’¢
        await context.bot.send_photo(
            chat_id=user_id, 
            photo=photo_id, 
            caption=message_text
        )
        
        await update.message.reply_text(
            f"‚úÖ ’Ü’Ø’°÷Ä’® ’∞’°’ª’∏’≤’∏÷Ç’©’µ’°’¥’¢ ’∏÷Ç’≤’°÷Ä’Ø’æ’•’¨ ’ß ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’® ID: {user_id}\n"
            f"üìù ’Ä’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂: {message_text if message_text else '‘≤’°÷Å’°’Ø’°’µ’∏÷Ç’¥ ’ß'}"
        )
        
        # ‘æ’°’∂’∏÷Ç÷Å’•’¨ ’°’§’¥’´’∂’´’∂
        await notify_admin(
            update, 
            context, 
            "’Ü’Ø’°÷Ä ’∏÷Ç’≤’°÷Ä’Ø’æ’°’Æ", 
            f"’Ü’Ø’°÷Ä’® ’∏÷Ç’≤’°÷Ä’Ø’æ’•’¨ ’ß ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’® {user_id}÷â ’Ä’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂: {message_text if message_text else '‘≤’°÷Å’°’Ø’°’µ’∏÷Ç’¥ ’ß'}"
        )
        
    except ValueError:
        await update.message.reply_text("‚ùå ’ç’≠’°’¨ user ID: ID-’∂ ’∫’•’ø÷Ñ ’ß ’¨’´’∂’´ ’©’´’æ")
    except Exception as e:
        error_msg = str(e)
        if "chat not found" in error_msg.lower():
            await update.message.reply_text("‚ùå ’â’∞’°’ª’∏’≤’æ’•÷Å ’£’ø’∂’•’¨ ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’®: ’Ä’∂’°÷Ä’°’æ’∏÷Ä ’ß ’∂’° ’°÷Ä’£’•’¨’°÷É’°’Ø’•’¨ ’ß ’¢’∏’ø’®")
        elif "blocked" in error_msg.lower():
            await update.message.reply_text("‚ùå ’ï’£’ø’°’ø’•÷Ä’® ’°÷Ä’£’•’¨’°÷É’°’Ø’•’¨ ’ß ’¢’∏’ø’®")
        else:
            await update.message.reply_text(f"‚ùå ’ç’≠’°’¨ ’∂’Ø’°÷Ä’® ’∏÷Ç’≤’°÷Ä’Ø’•’¨’´’Ω: {error_msg}")


# ‘±’æ’•’¨’°÷Å÷Ä’•÷Ñ ’°’µ’Ω ÷Ü’∏÷Ç’∂’Ø÷Å’´’°’∂ admin commands ’∞’°’ø’æ’°’Æ’∏÷Ç’¥
async def sendvideo_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("‚õî ’Ñ’´’°’µ’∂ ’°’§’¥’´’∂’∂’•÷Ä’´ ’∞’°’¥’°÷Ä")
        return

    # ’ç’ø’∏÷Ç’£’•’¨, ’∏÷Ä ÷Ö’£’ø’°’ø’•÷Ä’® reply ’ß ’°÷Ä’•’¨ ’æ’´’§’•’∏’µ’´’∂
    if not update.message.reply_to_message or not update.message.reply_to_message.video:
        await update.message.reply_text(
            "‚ùå ‘¥’∏÷Ç÷Ñ ’∫’•’ø÷Ñ ’ß ’∫’°’ø’°’Ω’≠’°’∂’•÷Ñ ’æ’´’§’•’∏’µ’´ ’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’°’∂’®\n\n"
            "‚ÑπÔ∏è ’ï’£’ø’°’£’∏÷Ä’Æ’∏÷Ç’¥:\n"
            "1. ’à÷Ç’≤’°÷Ä’Ø’•÷Ñ ’æ’´’§’•’∏ ’¢’∏’ø’´’∂\n"
            "2. ’ä’°’ø’°’Ω’≠’°’∂’•÷Ñ ’æ’´’§’•’∏’µ’´’∂ ’°’µ’Ω’∫’•’Ω’ù /sendvideo <user_id> <’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂>\n\n"
            "üìù ’ï÷Ä’´’∂’°’Ø’ù\n"
            "/sendvideo 123456789 ‘¥’´’ø’•÷Ñ ’°’µ’Ω ’ø’•’Ω’°’∂’µ’∏÷Ç’©’®"
        )
        return

    # ’ä’°÷Ä’°’¥’•’ø÷Ä’•÷Ä’´ ’Ω’ø’∏÷Ç’£’∏÷Ç’¥
    if not context.args:
        await update.message.reply_text("‚ùå ’Ñ’∏’º’°÷Å’•’¨ ’•÷Ñ ’∂’∑’•’¨ user ID-’∂")
        return

    try:
        user_id = int(context.args[0])
        video_id = update.message.reply_to_message.video.file_id
        
        # ’Ä’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’°’∂ ’Ω’ø’°÷Å’∏÷Ç’¥ (’¥’∂’°÷Å’°’Æ ’°÷Ä’£’∏÷Ç’¥’•’∂’ø’∂’•÷Ä’® ’¥’´’°÷Å’∂’•’¨ ’¥’•’Ø ’ø’•÷Ñ’Ω’ø’∏÷Ç’¥)
        message_text = ' '.join(context.args[1:]) if len(context.args) > 1 else None
        
        # ’ì’∏÷Ä’±’•’¨ ’∏÷Ç’≤’°÷Ä’Ø’•’¨ ’æ’´’§’•’∏’∂ ’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’°’¥’¢
        await context.bot.send_video(
            chat_id=user_id, 
            video=video_id, 
            caption=message_text
        )
        
        await update.message.reply_text(
            f"‚úÖ ’é’´’§’•’∏’∂ ’∞’°’ª’∏’≤’∏÷Ç’©’µ’°’¥’¢ ’∏÷Ç’≤’°÷Ä’Ø’æ’•’¨ ’ß ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’® ID: {user_id}\n"
            f"üìù ’Ä’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂: {message_text if message_text else '‘≤’°÷Å’°’Ø’°’µ’∏÷Ç’¥ ’ß'}"
        )
        
        # ‘æ’°’∂’∏÷Ç÷Å’•’¨ ’°’§’¥’´’∂’´’∂
        await notify_admin(
            update, 
            context, 
            "’é’´’§’•’∏ ’∏÷Ç’≤’°÷Ä’Ø’æ’°’Æ", 
            f"’é’´’§’•’∏’∂ ’∏÷Ç’≤’°÷Ä’Ø’æ’•’¨ ’ß ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’® {user_id}÷â ’Ä’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂: {message_text if message_text else '‘≤’°÷Å’°’Ø’°’µ’∏÷Ç’¥ ’ß'}"
        )
        
    except ValueError:
        await update.message.reply_text("‚ùå ’ç’≠’°’¨ user ID: ID-’∂ ’∫’•’ø÷Ñ ’ß ’¨’´’∂’´ ’©’´’æ")
    except Exception as e:
        error_msg = str(e)
        if "chat not found" in error_msg.lower():
            await update.message.reply_text("‚ùå ’â’∞’°’ª’∏’≤’æ’•÷Å ’£’ø’∂’•’¨ ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’®: ’Ä’∂’°÷Ä’°’æ’∏÷Ä ’ß ’∂’° ’°÷Ä’£’•’¨’°÷É’°’Ø’•’¨ ’ß ’¢’∏’ø’®")
        elif "blocked" in error_msg.lower():
            await update.message.reply_text("‚ùå ’ï’£’ø’°’ø’•÷Ä’® ’°÷Ä’£’•’¨’°÷É’°’Ø’•’¨ ’ß ’¢’∏’ø’®")
        else:
            await update.message.reply_text(f"‚ùå ’ç’≠’°’¨ ’æ’´’§’•’∏’∂ ’∏÷Ç’≤’°÷Ä’Ø’•’¨’´’Ω: {error_msg}")


# ‘±’æ’•’¨’°÷Å÷Ä’•÷Ñ ’°’µ’Ω ÷Ü’∏÷Ç’∂’Ø÷Å’´’°’∂ admin commands ’∞’°’ø’æ’°’Æ’∏÷Ç’¥
async def sendsticker_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("‚õî ’Ñ’´’°’µ’∂ ’°’§’¥’´’∂’∂’•÷Ä’´ ’∞’°’¥’°÷Ä")
        return

    # ’ç’ø’∏÷Ç’£’•’¨, ’∏÷Ä ÷Ö’£’ø’°’ø’•÷Ä’® reply ’ß ’°÷Ä’•’¨ ’Ω’ø’´’Ø’•÷Ä’´’∂
    if not update.message.reply_to_message or not update.message.reply_to_message.sticker:
        await update.message.reply_text(
            "‚ùå ‘¥’∏÷Ç÷Ñ ’∫’•’ø÷Ñ ’ß ’∫’°’ø’°’Ω’≠’°’∂’•÷Ñ ’Ω’ø’´’Ø’•÷Ä’´ ’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’°’∂’®\n\n"
            "‚ÑπÔ∏è ’ï’£’ø’°’£’∏÷Ä’Æ’∏÷Ç’¥:\n"
            "1. ’à÷Ç’≤’°÷Ä’Ø’•÷Ñ ’Ω’ø’´’Ø’•÷Ä ’¢’∏’ø’´’∂\n"
            "2. ’ä’°’ø’°’Ω’≠’°’∂’•÷Ñ ’Ω’ø’´’Ø’•÷Ä’´’∂ ’°’µ’Ω’∫’•’Ω’ù /sendsticker <user_id>\n\n"
            "üìù ’ï÷Ä’´’∂’°’Ø’ù\n"
            "/sendsticker 123456789"
        )
        return

    # ’ä’°÷Ä’°’¥’•’ø÷Ä’•÷Ä’´ ’Ω’ø’∏÷Ç’£’∏÷Ç’¥
    if not context.args:
        await update.message.reply_text("‚ùå ’Ñ’∏’º’°÷Å’•’¨ ’•÷Ñ ’∂’∑’•’¨ user ID-’∂")
        return

    try:
        user_id = int(context.args[0])
        sticker_id = update.message.reply_to_message.sticker.file_id
        
        # ’ì’∏÷Ä’±’•’¨ ’∏÷Ç’≤’°÷Ä’Ø’•’¨ ’Ω’ø’´’Ø’•÷Ä’®
        await context.bot.send_sticker(chat_id=user_id, sticker=sticker_id)
        
        await update.message.reply_text(
            f"‚úÖ ’ç’ø’´’Ø’•÷Ä’® ’∞’°’ª’∏’≤’∏÷Ç’©’µ’°’¥’¢ ’∏÷Ç’≤’°÷Ä’Ø’æ’•’¨ ’ß ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’® ID: {user_id}"
        )
        
        # ‘æ’°’∂’∏÷Ç÷Å’•’¨ ’°’§’¥’´’∂’´’∂
        await notify_admin(
            update, 
            context, 
            "’ç’ø’´’Ø’•÷Ä ’∏÷Ç’≤’°÷Ä’Ø’æ’°’Æ", 
            f"’ç’ø’´’Ø’•÷Ä’® ’∏÷Ç’≤’°÷Ä’Ø’æ’•’¨ ’ß ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’® {user_id}"
        )
        
    except ValueError:
        await update.message.reply_text("‚ùå ’ç’≠’°’¨ user ID: ID-’∂ ’∫’•’ø÷Ñ ’ß ’¨’´’∂’´ ’©’´’æ")
    except Exception as e:
        error_msg = str(e)
        if "chat not found" in error_msg.lower():
            await update.message.reply_text("‚ùå ’â’∞’°’ª’∏’≤’æ’•÷Å ’£’ø’∂’•’¨ ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’®: ’Ä’∂’°÷Ä’°’æ’∏÷Ä ’ß ’∂’° ’°÷Ä’£’•’¨’°÷É’°’Ø’•’¨ ’ß ’¢’∏’ø’®")
        elif "blocked" in error_msg.lower():
            await update.message.reply_text("‚ùå ’ï’£’ø’°’ø’•÷Ä’® ’°÷Ä’£’•’¨’°÷É’°’Ø’•’¨ ’ß ’¢’∏’ø’®")
        else:
            await update.message.reply_text(f"‚ùå ’ç’≠’°’¨ ’Ω’ø’´’Ø’•÷Ä’® ’∏÷Ç’≤’°÷Ä’Ø’•’¨’´’Ω: {error_msg}")

# ‘±’æ’•’¨’°÷Å÷Ä’•÷Ñ ’°’µ’Ω ÷Ü’∏÷Ç’∂’Ø÷Å’´’°’∂ admin commands ’∞’°’ø’æ’°’Æ’∏÷Ç’¥
async def sendgif_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("‚õî ’Ñ’´’°’µ’∂ ’°’§’¥’´’∂’∂’•÷Ä’´ ’∞’°’¥’°÷Ä")
        return

    # ’ç’ø’∏÷Ç’£’•’¨, ’∏÷Ä ÷Ö’£’ø’°’ø’•÷Ä’® reply ’ß ’°÷Ä’•’¨ GIF-’´’∂ (animation)
    if not update.message.reply_to_message or not update.message.reply_to_message.animation:
        await update.message.reply_text(
            "‚ùå ‘¥’∏÷Ç÷Ñ ’∫’•’ø÷Ñ ’ß ’∫’°’ø’°’Ω’≠’°’∂’•÷Ñ GIF-’´ ’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’°’∂’®\n\n"
            "‚ÑπÔ∏è ’ï’£’ø’°’£’∏÷Ä’Æ’∏÷Ç’¥:\n"
            "1. ’à÷Ç’≤’°÷Ä’Ø’•÷Ñ GIF ’¢’∏’ø’´’∂\n"
            "2. ’ä’°’ø’°’Ω’≠’°’∂’•÷Ñ GIF-’´’∂ ’°’µ’Ω’∫’•’Ω’ù /sendgif <user_id> <’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂>\n\n"
            "üìù ’ï÷Ä’´’∂’°’Ø’ù\n"
            "/sendgif 123456789 ‘∂’æ’°÷Ä’≥’°’¨’´ GIF ’±’•’¶ ’∞’°’¥’°÷Ä"
        )
        return

    # ’ä’°÷Ä’°’¥’•’ø÷Ä’•÷Ä’´ ’Ω’ø’∏÷Ç’£’∏÷Ç’¥
    if not context.args:
        await update.message.reply_text("‚ùå ’Ñ’∏’º’°÷Å’•’¨ ’•÷Ñ ’∂’∑’•’¨ user ID-’∂")
        return

    try:
        user_id = int(context.args[0])
        gif_id = update.message.reply_to_message.animation.file_id
        
        # ’Ä’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’°’∂ ’Ω’ø’°÷Å’∏÷Ç’¥ (’¥’∂’°÷Å’°’Æ ’°÷Ä’£’∏÷Ç’¥’•’∂’ø’∂’•÷Ä’® ’¥’´’°÷Å’∂’•’¨ ’¥’•’Ø ’ø’•÷Ñ’Ω’ø’∏÷Ç’¥)
        message_text = ' '.join(context.args[1:]) if len(context.args) > 1 else None
        
        # ’ì’∏÷Ä’±’•’¨ ’∏÷Ç’≤’°÷Ä’Ø’•’¨ GIF-’® ’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’°’¥’¢
        await context.bot.send_animation(
            chat_id=user_id, 
            animation=gif_id, 
            caption=message_text
        )
        
        await update.message.reply_text(
            f"‚úÖ GIF-’® ’∞’°’ª’∏’≤’∏÷Ç’©’µ’°’¥’¢ ’∏÷Ç’≤’°÷Ä’Ø’æ’•’¨ ’ß ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’® ID: {user_id}\n"
            f"üìù ’Ä’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂: {message_text if message_text else '‘≤’°÷Å’°’Ø’°’µ’∏÷Ç’¥ ’ß'}"
        )
        
        # ‘æ’°’∂’∏÷Ç÷Å’•’¨ ’°’§’¥’´’∂’´’∂
        await notify_admin(
            update, 
            context, 
            "GIF ’∏÷Ç’≤’°÷Ä’Ø’æ’°’Æ", 
            f"GIF-’® ’∏÷Ç’≤’°÷Ä’Ø’æ’•’¨ ’ß ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’® {user_id}÷â ’Ä’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂: {message_text if message_text else '‘≤’°÷Å’°’Ø’°’µ’∏÷Ç’¥ ’ß'}"
        )
        
    except ValueError:
        await update.message.reply_text("‚ùå ’ç’≠’°’¨ user ID: ID-’∂ ’∫’•’ø÷Ñ ’ß ’¨’´’∂’´ ’©’´’æ")
    except Exception as e:
        error_msg = str(e)
        if "chat not found" in error_msg.lower():
            await update.message.reply_text("‚ùå ’â’∞’°’ª’∏’≤’æ’•÷Å ’£’ø’∂’•’¨ ÷Ö’£’ø’°’ø’´÷Ä’∏’ª’®: ’Ä’∂’°÷Ä’°’æ’∏÷Ä ’ß ’∂’° ’°÷Ä’£’•’¨’°÷É’°’Ø’•’¨ ’ß ’¢’∏’ø’®")
        elif "blocked" in error_msg.lower():
            await update.message.reply_text("‚ùå ’ï’£’ø’°’ø’•÷Ä’® ’°÷Ä’£’•’¨’°÷É’°’Ø’•’¨ ’ß ’¢’∏’ø’®")
        else:
            await update.message.reply_text(f"‚ùå ’ç’≠’°’¨ GIF-’® ’∏÷Ç’≤’°÷Ä’Ø’•’¨’´’Ω: {error_msg}")

# ‘±’æ’•’¨’°÷Å÷Ä’•÷Ñ ’°’µ’Ω handler-’® main ÷Ü’∏÷Ç’∂’Ø÷Å’´’°’µ’∏÷Ç’¥
# ‘±’æ’•’¨’°÷Å÷Ä’•÷Ñ ’°’µ’Ω handler-’® main ÷Ü’∏÷Ç’∂’Ø÷Å’´’°’µ’∏÷Ç’¥

async def main():
    from telegram.ext import ApplicationBuilder
    application = ApplicationBuilder().token(TOKEN).build()

    application.add_handler(CallbackQueryHandler(lang_button_handler, pattern="^lang_"))

    # ‚úÖ Callback Handlers (button/menu/tool/admin/quiz)
    application.add_handler(CallbackQueryHandler(button_handler))
    application.add_handler(MessageHandler(filters.PHOTO, handle_broadcast_photo))
    
    application.add_handler(CommandHandler("broadcast_photo", broadcast_photo_command))
    application.add_handler(MessageHandler(filters.VIDEO, handle_broadcast_video))
    bruteforce_handler = ConversationHandler(
    entry_points=[CommandHandler("bruteforce", bruteforce_command)],
    states={
        ASK_WEBSITE: [MessageHandler(filters.TEXT & ~filters.COMMAND, bruteforce_process)],
    },
    fallbacks=[CommandHandler("cancel", bruteforce_cancel)],
    )
    application.add_handler(bruteforce_handler)
    application.add_handler(MessageHandler(filters.Document.ALL, handle_broadcast_file))
    application.add_handler(CallbackQueryHandler(admin_callback_handler, pattern='^admin_'))
    application.add_handler(CallbackQueryHandler(referral_command, pattern="^referral$"))
    application.add_handler(CallbackQueryHandler(quiz_command, pattern="^quiz$"))
    application.add_handler(CallbackQueryHandler(quiz_start_callback, pattern="quiz_start"))
    application.add_handler(CallbackQueryHandler(quiz_answer_callback, pattern="quiz_1|quiz_2|quiz_3"))
    application.add_handler(CallbackQueryHandler(tool_shortcut_handler, pattern='^(ip_tool|whois_tool|passgen_tool|hash_tool|nmap_tool|bruteforce_tool|phish_tool|quiz|fact|rules|help|leaderboard|daily|xp|shop|wallet|faucet|buy_coins)$'))
    application.add_handler(CallbackQueryHandler(fullmenu_button_handler, pattern='^(casino|tools|shop|quiz|admin|full_menu|casino_xp|tools_hack|shop_wallet|quiz_facts|admin_panel)$'))
    application.add_handler(CallbackQueryHandler(quiz_answer_handler, pattern='^quiz_answer:'))
    application.add_handler(CallbackQueryHandler(lang_button_handler, pattern='^lang_'))

    # ‚úÖ Core Commands
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("balance", balance_command))
    application.add_handler(CommandHandler("menu", menu_command))
    application.add_handler(CommandHandler("destroy", destroy_command))
    application.add_handler(CommandHandler("referral", referral_command))
    application.add_handler(CommandHandler("sendgif", sendgif_command))
    application.add_handler(CommandHandler("sendphoto", sendphoto_command))
    application.add_handler(CommandHandler("daily", daily_command))
    application.add_handler(CommandHandler("sendvideo", sendvideo_command))
    application.add_handler(CommandHandler("xp", xp_command))
    application.add_handler(CommandHandler("quiz", quiz_command))
    application.add_handler(CommandHandler("sendsticker", sendsticker_command))

    # ‚úÖ Admin Commands
    application.add_handler(CommandHandler("broadcast", broadcast_command))
    application.add_handler(CommandHandler("broadcast_all", broadcast_text_all))
    application.add_handler(CommandHandler("broadcast_photo", broadcast_photo_command))
    application.add_handler(CommandHandler("broadcast_file", broadcast_file_command))
    application.add_handler(CommandHandler("ip", ip_command))
    application.add_handler(MessageHandler(filters.LOCATION, location_handler))

    application.add_handler(MessageHandler(filters.StatusUpdate.WEB_APP_DATA, handle_webapp_data))  # WebApp data
    application.add_handler(CommandHandler("broadcast_video", broadcast_video_command))
    application.add_handler(CommandHandler("reply", reply_command))
    application.add_handler(CommandHandler("block", block_user))
    application.add_handler(CommandHandler("showusers", show_all_users))
    application.add_handler(CommandHandler("adduser", add_user))
    application.add_handler(CommandHandler("removeuser", remove_user))
    application.add_handler(CommandHandler("unblock", unblock_user))
    application.add_handler(CommandHandler("sendpromo", send_promo_code))
    application.add_handler(CommandHandler("block_all", block_all_users))
    application.add_handler(CommandHandler("unblock_all", unblock_all_users))
    application.add_handler(CommandHandler("broadcast_poll", broadcast_poll_command))
    application.add_handler(CommandHandler("blocked_count", blocked_count))
    application.add_handler(CommandHandler("list_blocked", list_blocked_command))
    application.add_handler(CommandHandler("delete_user", delete_user_command))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("userinfo", user_info_by_id))
    application.add_handler(CommandHandler("search", admin_search))
    application.add_handler(CommandHandler("play", play_command))
    application.add_handler(CommandHandler("admin", admin))
    application.add_handler(CommandHandler("vip_add", vip_add))
    application.add_handler(MessageHandler(filters.Dice.ALL, handle_dice))
    application.add_handler(CommandHandler("score", score_command))
    application.add_handler(CommandHandler("top", top_command))
    application.add_handler(CommandHandler("vip_remove", vip_remove))
    application.add_handler(CommandHandler("purge", purge_all_blocked))
    application.add_handler(CommandHandler("purge_blocked", purge_all_blocked))
    application.add_handler(CommandHandler("export", backup_users))
    application.add_handler(CallbackQueryHandler(admin_vip_add, pattern="^admin_vip_add$"))
    application.add_handler(CallbackQueryHandler(admin_vip_remove, pattern="^admin_vip_remove$"))
    application.add_handler(CallbackQueryHandler(handle_vip_add, pattern="^vip_add_"))
    application.add_handler(CallbackQueryHandler(handle_vip_remove, pattern="^vip_remove_"))
    application.add_handler(CommandHandler("backup_users", backup_users))
    application.add_handler(CommandHandler("restore_users", restore_users))
    application.add_handler(CallbackQueryHandler(quiz_answer_handler, pattern="^quiz_answer:"))
    application.add_handler(CommandHandler("clean_user", clean_user_command))
    application.add_handler(CommandHandler("inspect", inspect_user))
    application.add_handler(MessageHandler(filters.COMMAND, unknown_command))
    
    unknown_command_filter = filters.Regex(r"^/") & ~filters.COMMAND
    application.add_handler(MessageHandler(unknown_command_filter, unknown_command))

    # ‚úÖ Giveaway
    application.add_handler(CommandHandler("join_giveaway", join_giveaway))
    application.add_handler(CommandHandler("giveaway_status", giveaway_status))
    application.add_handler(CommandHandler("draw_winner", draw_winner))

    # ‚úÖ Tools
    application.add_handler(CommandHandler("hash", hash_command))
    application.add_handler(CommandHandler("base64", base64_command))
    application.add_handler(CommandHandler("genpass", genpass_command))
    application.add_handler(CommandHandler("whois", whois_command))
    application.add_handler(CommandHandler("iplookup", iplookup_command))
    application.add_handler(CommandHandler("nmap", nmap_command))
    application.add_handler(CommandHandler("broadcast_poll", broadcast_poll_command))
    application.add_handler(MessageHandler(filters.POLL, handle_poll))
    application.add_handler(PollAnswerHandler(handle_poll_answer))
    application.add_handler(CommandHandler("bruteforce", bruteforce_command))
    application.add_handler(CommandHandler("phish", phish_command))

    # ‚úÖ Help & Info
    application.add_handler(CommandHandler("rules", rules_command))
    application.add_handler(CommandHandler("shop", shop_command))
    application.add_handler(CommandHandler("buy", buy_command))
    application.add_handler(CommandHandler("leaderboard", leaderboard_command))

    # ‚úÖ Media Handlers (user content)
    application.add_handler(MessageHandler(filters.PHOTO & ~filters.FORWARDED, handle_photos))
    application.add_handler(MessageHandler(filters.VIDEO & ~filters.FORWARDED, handle_videos))
    application.add_handler(MessageHandler(filters.Document.ALL & ~filters.FORWARDED, handle_documents))
    application.add_handler(MessageHandler(filters.VOICE, handle_voices))
    application.add_handler(MessageHandler(filters.AUDIO, handle_audios))
    application.add_handler(MessageHandler(filters.CONTACT, handle_contact))
    application.add_handler(MessageHandler(filters.LOCATION, handle_location))
    application.add_handler(MessageHandler(filters.ANIMATION, handle_animations))
    application.add_handler(MessageHandler(filters.POLL, handle_poll))
    application.add_handler(MessageHandler(filters.Sticker.ALL, handle_sticker))

    # ‚úÖ Media Handlers (broadcasted/forwarded)
    application.add_handler(CommandHandler("broadcast_photo", broadcast_photo_command))
    application.add_handler(MessageHandler(filters.VIDEO & filters.FORWARDED, handle_broadcast_video))
    application.add_handler(MessageHandler(filters.Document.ALL & filters.FORWARDED, handle_broadcast_file))

    # ‚úÖ Text handler (non-command)
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    print("Bot is running...")
    await application.run_polling()


if __name__ == "__main__":
    asyncio.run(main())




from io import StringIO
from telegram import InputFile

# Export Users to CSV


async def export_users(update, context):
    if update.effective_user.id != admin_id:
        return await send_and_auto_delete_message(context, update.effective_chat.id, "‚õî Admin access only")

    output = StringIO()
    output.write("user_id,username,full_name,balance,level,subscription,referral_count\n")
    for uid in all_users:
        data = user_data.get(uid, {})
        output.write(f"{uid},{data.get('username','')},{data.get('full_name','')},{data.get('balance',0)},{data.get('level',1)},{'Yes' if data.get('subscription') else 'No'},{data.get('referral_count',0)}\n")

    output.seek(0)
    await context.bot.send_document(
        chat_id=update.effective_chat.id,
        document=InputFile(output, filename="users_export.csv"),
        caption="üìÅ Exported Users CSV"
    )

# Purge Blocked Users


async def purge_blocked(update, context):
    if update.effective_user.id != admin_id:
        return
    count = len(blocked_users)
    blocked_users.clear()
    await send_and_auto_delete_message(context, update.effective_chat.id, f"üßπ Cleared {count} blocked users.")

# Send Promo Code





# ================= LANGUAGE SETUP ===================
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from shared_state import user_data

LANGUAGES = {
    'en': 'üá¨üáß English',
    'ru': 'üá∑üá∫ –†—É—Å—Å–∫–∏–π',
    'fr': 'üá´üá∑ Fran√ßais',
    'hy': 'üá¶üá≤ ’Ä’°’µ’•÷Ä’•’∂',
}



async def setlang_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton(text=label, callback_data=f'setlang_{code}')]
        for code, label in LANGUAGES.items()
    ]
    if update.message:
        await send_and_auto_delete_message(context, update.effective_chat.id, 
            "üåç ‘∏’∂’ø÷Ä’•÷Ñ ’¨’•’¶’∏÷Ç’∂ / Choose your language:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    elif update.callback_query:
        await update.callback_query.message.reply_text(
            "üåç ‘∏’∂’ø÷Ä’•÷Ñ ’¨’•’¶’∏÷Ç’∂ / Choose your language:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )



async def language_button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user = query.from_user
    user_id = user.id

    if query.data.startswith("setlang_"):
        lang_code = query.data.split("_")[1]
        user_info = user_data.setdefault(user_id, {})
        user_info['lang'] = lang_code
        user_info['user_lang_set'] = True

        await query.edit_message_text("‚úÖ ‘º’•’¶’∏÷Ç’∂ ’®’∂’ø÷Ä’æ’°’Æ ’ß÷â / Language set.")
        await send_and_auto_delete_message(context, chat_id=user_id, text="/start")


from lang import get_text

from final_bot_corrected import save_data

async def start(update, context):
    user = update.effective_user
    user_id = user.id

    # ‚úÖ ’Ñ’´’∑’ø ’£÷Ä’°’∂÷Å’∏÷Ç’¥ ’•’∂÷Ñ user-’´’∂ ÷á ’∫’°’∞’∫’°’∂’∏÷Ç’¥ ÷Ü’°’µ’¨’∏÷Ç’¥
    if user_id not in all_users:
        all_users.add(user_id)
        save_data()

    # ’ç’Ø’¶’¢’∂’°’Ø’°’∂ user_data
    user_info = user_data.setdefault(user_id, {
        "user_lang_set": False,
        "lang": "en"
    })

    # ‘µ’©’• ’¨’•’¶’∏÷Ç’∂ ’§’•’º ’®’∂’ø÷Ä’°’Æ ’π’ß ‚Üí ’°’º’°’ª’°÷Ä’Ø’∏÷Ç’¥ ’•’∂÷Ñ ’®’∂’ø÷Ä’•’¨
    if not user_info.get("user_lang_set"):
        await setlang_command(update, context)
        return

    # ’Ä’°’Ø’°’º’°’Ø ’§’•’∫÷Ñ’∏÷Ç’¥ ’∏÷Ç’≤’°÷Ä’Ø’∏÷Ç’¥ ’•’∂÷Ñ welcome ’∞’°’≤’∏÷Ä’§’°’£÷Ä’∏÷Ç’©’µ’∏÷Ç’∂’®
    text = get_text(user_id, "start_welcome")
    await send_and_auto_delete_message(
        context,
        chat_id=update.effective_chat.id,
        text=text
    )